<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='raptor64.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: raptor64
    <br/>
    Created: Apr 26, 2012
    <br/>
    Updated: Feb 16, 2013
    <br/>
    SVN Updated: Feb 18, 2013
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Processor
    
    <br/>
    Language:
    
     Verilog
    
    <br/>
    Development status:
    
     Planning
    
    <br/>
    Additional info:
    <br/>
    WishBone Compliant: No
    <br/>
    License: LGPL
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     Raptor64 is a 64-bit multi-context RISC cpu that supports hyper-threading. There are 16 register sets that the processor automatically switches between at high speed. The processor is fully pipelined with a nine-stage pipeline. Stages: IF/RF/EX/M1/M2/M3/M4/WB/TR. Communication with memory is via a 32 bit MIG bus. The processor has a 8kB instruction cache and 16kB data cache. Also included is a 16 entry TLB for memory management. The processor uses 32 bit instructions.
     <br/>
     I've created two versions of the processor a non-hyper-threaded version (sc) in addition to the hyper-threaded multi-context(mc) one.
     <br/>
    </p>
   </div>
   <div id="d_Features">
    <h2>
     
     
     Features
    </h2>
    <p id="p_Features">
     - 32 entry 64 bit general register file
     <br/>
     - 32 bit opcodes (4 per 128 bits)
     <br/>
     - SQRT,Multiply/Divide/bit field/ + all the regulars
     <br/>
     - conditional move, exec,
     <br/>
     - explicit I/O instructions ( also useful for uncached access)
     <br/>
     - immediate constants may be built using SETLO,SETMID,SETHI instructions
     <br/>
     - two address modes, displacement (d15[ra]) and scaled indexed (d2[ra+rb*scale])
     <br/>
     - 16 segmentation registers
     <br/>
     - SimpleMMU - 32 tasks supported with mapping of 128MB space into 256kB pages
     <br/>
     - 64 single bit semaphores
     <br/>
     - 8kiB instruction cache, 16kiB data cache
     <br/>
     - 8 way 8 entry set associative TLB
     <br/>
     - single cycle execution of most instructions (loads stall the pipeline)
     <br/>
     - branch prediction with a 256 entry branch history table
     <br/>
     - return address stack prediction
     <br/>
     - internal Harvard architecture
     <br/>
     - communicates externally using a 64-bit WISHBONE bus
     <br/>
    </p>
   </div>
   <div id="d_Software">
    <h2>
     
     
     Software
    </h2>
    <p id="p_Software">
     In the works is currently a high level language compiler for a language similar to 'C'. Several additional keywords have been added (eg. interrupt). Well I finally fed the output of the compiler through the assembler. A couple of bug fixes later the sieve is able to run from SD Card.
     <br/>
     There is also an assembler (also a work in progress).
     <br/>
     Tiny Basic is available in the boot rom. Works with a few bugs yet.
     <br/>
    </p>
   </div>
   <div id="d_Status">
    <h2>
     
     
     Status
    </h2>
    <p id="p_Status">
     Currently the processor is running code in an FPGA. The bootrom is slowly expanding. Numerous software and processor fixes have taken place. Still a long way to go. The processor is being revamped to use a 32 bit ISA, it was originally a 42 bit ISA.
     <br/>
     The core is running on an Atlys board, and now able to load a boot program from an SD Card. Hopefully that will speed the software development up. Prior, the only software was updated by updating a Verilog source file, requiring the entire system to be rebuilt for a software update.
     <br/>
     The ISA is still under constant review; it may change to use an 8-bit master opcode field as opposed to 7-bits. There's lots of instructions I'd like to add, and no room with only 7 bits.
     <br/>
    </p>
   </div>
   <div id="d_Pics">
    <h2>
     
     
     Pics
    </h2>
    <p id="p_Pics">
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
