<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='cpu8080.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: cpu8080
    <br/>
    Created: Oct  4, 2006
    <br/>
    Updated: Mar  6, 2012
    <br/>
    SVN Updated: Mar 10, 2009
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Processor
    
    <br/>
    Language:
    
     Verilog
    
    <br/>
    Development status:
    
     Stable
    
    <br/>
    Additional info:
    
     Design done
    
    <br/>
    WishBone Compliant: No
    <br/>
    License:
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     This is an 8080 core I created as a project to get to know Verilog.
     <br/>
     The 8080 was the second in the series 8008-&gt;8080-&gt;Z80. It was the second
     <br/>
     commercially available single chip CPU (disregarding the required
     <br/>
     clock and demultiplexor chips), after the 4 bit 4004. Besides being an interesting
     <br/>
     project, it also can serve as a very compact core, suitable for a supervisor role on an
     <br/>
     FPGA with other blocks. It has extensive support, all freely available, including
     <br/>
     assemblers, compilers, an operating system (CP/M).
     <br/>
     Although the Z80 is a more popular core due to being a superset of the 8080, the Z80
     <br/>
     takes considerably more chip real estate.  Its likely that more than 50% of available
     <br/>
     software is 8080 only, since the Z80 was often used to run 8080 code. For example,
     <br/>
     the CP/M OS itself was 8080 only code.
     <br/>
     This means that the 8080 can be an attractive core if you want the great support of
     <br/>
     this processor series, but need it to fit in less space.
     <br/>
     The core is fully instruction compatible with 8080, but not signal compatible. The
     <br/>
     original 8080 was a multiplexed nightmare. one of the original selling points of the Z80
     <br/>
     was its cleanup of the signals, and the 8080 itself had a companion chip that
     <br/>
     demultiplexed it.
     <br/>
     There are a few other similar chips on opencores. This one is a bit different because
     <br/>
     it is only 8080, and is in native Verilog (not a translation). Further, the goal was to
     <br/>
     get it down to the minimum in both source size and synthesized size.
     <br/>
     I also suspect there is a preverse advantage to running this core: its original
     <br/>
     manufacturer no longer makes it, or any compatible chip, and it has probally passed
     <br/>
     from any IP protection long ago. However, as usual, Should warn that I have not
     <br/>
     verified any legal status on this processor and do not speak from any knowledge or
     <br/>
     authority on the matter.
     <br/>
    </p>
   </div>
   <div id="d_Features">
    <h2>
     
     
     Features
    </h2>
    <p id="p_Features">
     Instruction set: 8080
     <br/>
     Data size: 8 bit
     <br/>
     Address: 16 bit
     <br/>
     Instruction: 8 bit
     <br/>
     Language: Verilog
     <br/>
     License: None (public domain)
     <br/>
     Created under: Xilinx ISE, free webpack edition
     <br/>
     Device: xc3c1000-4ft256
     <br/>
     Slices: 1104
     <br/>
     Slice flip flops: 296
     <br/>
     4 input LUTs: 2082
     <br/>
     Bonded IOBs: 33
     <br/>
     GCLKs: 1
     <br/>
     The CPU works entirely on positive clock edges and signals, but could be reconfigured
     <br/>
     easily.  It has wait state ability, and simple interrupt request/acknowledge structure.
     <br/>
     The original 8080 method of fetching an external instruction to satisfy the interrupt is
     <br/>
     preserved, and it is left up to an external interrupt controller to provide vectoring.
     <br/>
     I have no problem with, and in fact encourage, commercial use, modifications (public
     <br/>
     and private), etc.
     <br/>
    </p>
   </div>
   <div id="d_Status">
    <h2>
     
     
     Status
    </h2>
    <p id="p_Status">
     Notice:
     <br/>
     The CPU8080 project has passed a very complete CPU instruction test, and has run
     <br/>
     a medium (but not large) piece of code, the SCS1 monitor, this morning. I have marked
     <br/>
     the project as complete.
     <br/>
     Tonight, after consideration, I think I will call it complete, at least for a while. I was
     <br/>
     planning to take the design to a CP/M boot, but I think I have accomplished my
     <br/>
     original purpose, and more. I have high confidence in this core, and I hope you all can
     <br/>
     find uses for it. In the meantime, I have other projects, and my paid work calling.
     <br/>
     Feel free to email me questions. Good luck, and good success with your projects.
     <br/>
     2006/11/20 Status:
     <br/>
     The SCS1 monitor/assembler signs on!
     <br/>
     
      http://www.moorecad.com/fpga2.jpg
     
     <br/>
     Here it is shown signing on, and executing a "dump 0 30" command to dump the first
     <br/>
     30h bytes in the system.
     <br/>
     The wires trailing off the XESS board are the Intronix USB analyzer wires.
     <br/>
     Note that I added the sign on message to SCS1, normally it has no sign on.
     <br/>
     This marks the first major piece of original 8080 software CPU8080 has run. I am
     <br/>
     promoting the project status because of it.
     <br/>
     2006/11/18 Status:
     <br/>
     cpu8080 passes the Kelly Smith test, both in simulation and in hardware. There were
     <br/>
     8 different cpu bugs solved by my count, so this is a very important series of updates.
     <br/>
     Kelly Smith is an 8080 CPU test created in 1980 under the Microcosm Associates
     <br/>
     brand name, and donated to the "SIG/M" CP/M user's group.
     <br/>
     Its a very complete CPU test for all flags, modes and instructions, so passing that is
     <br/>
     very good for the design.
     <br/>
     Chris Strahm's modifications were incorporated, which include the following:
     <br/>
     1. All constants that are not a single bit have their bit width specified. This was
     <br/>
     required to remove Quartus errors.
     <br/>
     2. Wait state ability is now optional. See cpu8080.v.
     <br/>
     3. I/O instructions are now optional. See cpu8080.v.
     <br/>
     The last two are part of the "super compact" core concept that Mr. Strahm is
     <br/>
     following. See the section below for more details on this.
     <br/>
     2006/11/15 Status:
     <br/>
     The ADM 3A terminal emulation is very complete now. There are only a few modes
     <br/>
     missing, reduced intensity and graphics. There are still a few issues with the
     <br/>
     emulation, but they are minor, and should not impact any software.
     <br/>
     Going forward, I have hooked up with Rich Cini's excellent Altair website and project
     <br/>
     page at:
     <br/>
     
      http://www.altair32.com
     
     <br/>
     And the material there is really going to help me speed up this work.
     <br/>
     I want to emphasize that I am not creating a "computer history" project here. The
     <br/>
     logic is simple: The most complete test of a CPU is to run an extensive suite of
     <br/>
     existing software, and that means existing operating systems, compilers and utilities,
     <br/>
     of which the 8080 has quite a large supply. With the 8080 being more than 30 years
     <br/>
     old, any such systems are going to look like a history project. The reason it's useful
     <br/>
     to me is that a popular computer has a lot of preexisting software available for it.
     <br/>
     In fact, Rich's site has already taken care of a large peice of work I had yet to do,
     <br/>
     there is a full CPU test suite available there, 8080test.asm. The code is dated 1980,
     <br/>
     and I'll bet the author never would have imagined it would be used to proof a new
     <br/>
     implementation of the 8080. I'll post the result when that runs, which should be
     <br/>
     shortly.
     <br/>
     Moving forward from there, the only piece of hardware left to emulate is the Altair
     <br/>
     floppy disc controller, which looks pretty simple. After that, I will be able to use
     <br/>
     Rich's rich catalog of disc images including CP/M 2.2, Microsoft Basic and others to
     <br/>
     do a full 8080 checkout without so much as performing an assembly.
     <br/>
     There is a Altera/Quartus version of the CPU being developed by a user who has been
     <br/>
     emailing me of late. I hope to have more news on this later.
     <br/>
     Previous status:
     <br/>
     The design runs, abet with a simple program, on an XESS 1000 board. It prints
     <br/>
     "Hello, FPGA world" on a VGA display. Here is a picture:
     <br/>
     
      http://www.moorecad.com/fpga.JPG
     
     <br/>
     There have been a lot of improvements since the last version. First, I switched to the
     <br/>
     50 mhz clkb, which gets divided down from the 100 XESS board clock. There are a
     <br/>
     couple of reasons for this. The CPU core appeared to be deeply unhappy about running
     <br/>
     at the top speed of the FPGA, and was showing internal failures. Second, the raw
     <br/>
     100 mhz clock was coming direct from the oscillator, which I believe has a non-50/50
     <br/>
     duty cycle. Since I have been using both edges, that's bad.
     <br/>
     Second, I switched most clocking to positive edges. In fact, there is only one negedge
     <br/>
     left, and that's because I haven't had time to test it.
     <br/>
     Third, all of the read and write signals from the CPU, I/O and memory, were extended
     <br/>
     by a cycle. This was required to get the single edge clocking going, and relaxes the
     <br/>
     timing all around.
     <br/>
     With these changes, the design is now running quite well. The "hello, FPGA world"
     <br/>
     example now runs a terminal emulator loop, and the ADM 3A dumb terminal is fairly
     <br/>
     complete. It features shift, caps, and control keys on input, and obeys the ADM 3A
     <br/>
     controls, most of them, on output. See vgachr.v for details on what is and is not
     <br/>
     implemented.
     <br/>
     By entering various characters in the terminal mode, I have tested all the usual
     <br/>
     control characters, line up, down, left, right, clear screen, etc.
     <br/>
     For anyone who has got far with trying this design out, I'll apologize in advance for
     <br/>
     the character font. It was banged out in about 2 hours, I just wanted something
     <br/>
     for test. I'll be cleaning it up later.
     <br/>
     I'm currently using a Intronix 34 channel USB logic analyzer to verify the design on
     <br/>
     hardware. Chipscope was just out of reach for me, it not only takes about $800 for
     <br/>
     a full version, but requires you also to purchase the full, not free, version of ISE,
     <br/>
     bringing the total cost to about $3000. I have all of the CPU signals brought out to
     <br/>
     the analyzer, plus you'll notice an 8 bit "debug" bus that replaces the top 8 bits
     <br/>
     of the address lines. This technique allows me to attach various signals to the "bus"
     <br/>
     to be routed out to the external analyzer, and I can swap this to and from the debug
     <br/>
     bus by modifying the pin assignments at the top level.
     <br/>
     What's next is the Imsai monitor/assembler discussed below. I'm going to run that
     <br/>
     under a simulator first, so that is 1 to 2 weeks off. I'll post a new picture when that
     <br/>
     runs.
     <br/>
     The testbench so far on the hardware consists of the following:
     <br/>
     8080 core
     <br/>
     ROM to store test program ("hello"/terminal emulator)
     <br/>
     RAM
     <br/>
     Select controller
     <br/>
     Interrupt controller (no plans to use this on the hardware)
     <br/>
     ADM 3A Dumb Terminal emulator
     <br/>
     The wait state capability, as of this writing, has not been verified. For anyone curious,
     <br/>
     the "select controller" has bits reserved for this, bits 0 and 1 of the mask register
     <br/>
     will select from 0 to 3 wait states for that select.
     <br/>
     I plan to add a bus hold (tristate) and acknowledge pins and mode, this will allow
     <br/>
     connection of an external DMA. I don't plan to actually create a DMA, since this
     <br/>
     project needs to end (da' wife is getting annoyed). I'll just activate the hold pin and
     <br/>
     watch for high-z on all outputs.
     <br/>
     I also plan to add a NMI (non maskable interrupt) pin. That will get a simple test
     <br/>
     as well.
     <br/>
     I placed an assembler file in the source that I will use for first tests with the core:
     <br/>
     scs1.asm - An IMSAI monitor/assembler
     <br/>
     This is a famous old program for the 8080. It preceeds CP/M. It's interesting
     <br/>
     as first test because it only uses a single I/O port to the console.
     <br/>
    </p>
   </div>
   <div id="d_Development systems">
    <h2>
     
     
     Development systems
    </h2>
    <p id="p_Development systems">
     There is TONS of software available for the 8080. The best way to go about it is to run
     <br/>
     a CP/M simulator on your host machine. Here are a few:
     <br/>
     
      http://www.schorn.ch/cpm/intro.html
     
     <br/>
     
      http://www.moria.de/~michael/yaze-cpm3/
     
     <br/>
     For development systems, try these forums:
     <br/>
     
      http://www.retroarchive.org
     
     <br/>
     
      http://www.cpm.z80.de/
     
     <br/>
     This includes CP/M, assemblers, a basic compiler, the original Microsoft Basic interpreter,
     <br/>
     Fortan compilers, Cobol, C (of course), Pascal, Modula, Algol, and Ada.
     <br/>
     You can find a lot more with a simple search.
     <br/>
     CP/M itself is a good, small operating system to run on your target if you wish. It can be
     <br/>
     adapted to your target hardware with a very simple BIOS, which can run using a flash
     <br/>
     memory as the "disk" for it. The entire system fits in less than 256kb (yes, actually less
     <br/>
     than a meg), which was the common size of a floppy disk back when this CPU was
     <br/>
     popular.
     <br/>
     If you choose to run CP/M, the amount of software available is truly amazing. Try
     <br/>
     these sections of the retroarchive:
     <br/>
     
      http://www.retroarchive.org/cpm/cdrom/
     
     <br/>
     
      http://www.retroarchive.org/cpm/cdrom/SIMTEL/SIGM/
     
     <br/>
     CP/M was a popular system from the start of the home computer revolution to well
     <br/>
     into the 1980's, and continues to have a following today.
     <br/>
     I use a proprietary development system, the IP toolset, at my web site. This is not
     <br/>
     meant as a plug for that system (the 8080 version is not even for sale), but simply to
     <br/>
     explain why you will see a lot of the support files for the assembly code configured
     <br/>
     for that system. There is nothing I have here that you cannot find for free at the
     <br/>
     above sources. The main advantage I get from the IP toolset is that it runs natively
     <br/>
     under Windows/XP.
    </p>
   </div>
   <div id="d_Legal notice">
    <h2>
     
     
     Legal notice
    </h2>
    <p id="p_Legal notice">
     The 8080 CPU implemented here was created as a not for profit student project. I don't
     <br/>
     know if  its use will violate patents, copyrights, trademark rights or other rights. The
     <br/>
     source files were created entirely by me, but their use, commercial or otherwise, and
     <br/>
     any legal, consequences that arise, are entirely the responsibility of the user. I
     <br/>
     specifically deny that this core is usable for life support systems, or any other system
     <br/>
     that can or will cause, directly or indirectly, any harm to persons or property.
     <br/>
     THESE SOURCE FILES ARE PROVIDED "AS IS" AND WITHOUT ANY
     <br/>
     EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
     <br/>
     LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND
     <br/>
     FITNESS FOR A PARTICULAR PURPOSE.
    </p>
   </div>
   <div id="d_CVS Format">
    <h2>
     
     
     CVS Format
    </h2>
    <p id="p_CVS Format">
     The CVS repository is under cpu8080.
     <br/>
     I'll apologize in advance, but repository is basically a dump of my Xilinx ISE directory. This
     <br/>
     is not the clean way to do it, but it does have the advantage that if you are running
     <br/>
     ISE, you can download the entire thing and just go. Here is a list of the important files
     <br/>
     in the directory:
     <br/>
     readme.txt - A copy of this text
     <br/>
     cpu8080.txt - The documentation for the project, in plain ASCII.
     <br/>
     cpu8080.v - The 8080 core
     <br/>
     testbench.v - The testbench for the core. Also contains the peripherals for the core,
     <br/>
     such as the peripheral select controller, the interrupt controller, the test ROM, RAM, and
     <br/>
     anything else required.
     <br/>
     vgachr.v - The ADM 3A dumb terminal emulator, keyboard interface, and MITS Serial
     <br/>
     I/O emulator.
     <br/>
     vga.vhd - The stripped XESS vga timing generator/pixel shift register.
     <br/>
     ps2_kbd.vhd - The XESS keyboard interface.
     <br/>
     The other files are the testbench running files, like the stimulus package. I don't even
     <br/>
     know what half of them are, sorry, I only started using the system 2 weeks ago!
    </p>
   </div>
   <div id="d_Shameless plug">
    <h2>
     
     
     Shameless plug
    </h2>
    <p id="p_Shameless plug">
     For people who want ask me questions, or find out more about what I am doing, my
     <br/>
     information is:
     <br/>
     Email: samiam@moorecad.com
     <br/>
     Web page:
     
      http://www.moorecad.com
     
     <br/>
     Disclaimer: The above web page does include commercial content, ads, rants, etc.
    </p>
   </div>
   <div id="d_Documentation">
    <h2>
     
     
     Documentation
    </h2>
    <p id="p_Documentation">
     Here are some locations that have the original 8080 documentation:
     <br/>
     
      http://vt100.net/mirror/harte/Intel%208080%20Manual/
     
     <br/>
     
      http://www.hartetechnologies.com/manuals/Intel%208080%20Manual/
     
     <br/>
     
      http://www.imsai.net/whatsnew.htm
     
     <br/>
     
      http://www.classiccmp.org/dunfield/heath/index.htm
     
     <br/>
     That last link contains the "8080 Assembly language programming manual", which is the
     <br/>
     book that I used to construct cpu8080, from my original coffee stained edition, bought in
     <br/>
     1977.
     <br/>
     For people interested in the difference between the 8080 and its predecessor, the 8008,
     <br/>
     the following site is available:
     <br/>
     
      http://www.bitsavers.org/pdf/intel/MCS8/
     
     <br/>
     You can find the User's reference manual for the ADM 3A dumb terminal, which was used
     <br/>
     to produce the emulation used in this design, at:
     <br/>
     
      http://www.bitsavers.org/pdf/learSiegler/
     
     <br/>
     You can find a copy of the manual for the REALLY elementary MITS Serial I/O card used
     <br/>
     to construct the serial port emulation on the design at:
     <br/>
     
      http://www.classiccmp.org/dunfield/s100c/mits/88sio_1.pdf
     
    </p>
   </div>
   <div id="d_The super compact core">
    <h2>
     
     
     The super compact core
    </h2>
    <p id="p_The super compact core">
     Chris Strahm has been working on a "super compact" 8080 core. The idea is to strip out
     <br/>
     features that are not absolutely required for most designs.
     <br/>
     He's been reporting cell counts (LUTS) of below 1500.
     <br/>
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
