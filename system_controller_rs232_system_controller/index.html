<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='rs232_syscon.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: rs232_syscon
    <br/>
    Created: Sep 25, 2001
    <br/>
    Updated: Jan 23, 2015
    <br/>
    SVN Updated: Jul 14, 2013
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     System controller
    
    <br/>
    Language:
    
     Verilog &amp; VHDL
    
    <br/>
    Development status:
    
     Stable
    
    <br/>
    Additional info:
    
     Design done
    
    ,
    
     FPGA proven
    
    <br/>
    WishBone Compliant: Yes
    <br/>
    License: LGPL
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     rs232_syscon is a synthesizeable soft core that allows debugging of peripherals connected to a Wishbone type of bus. Specifically, it lets the user write and read registers, and send out reset pulses, via an rs232 serial connection to a "dumb terminal." (Such as windows "hyperterm"!) It is completely scalable through parameter settings, to accomodate address and data buses of any arbitrary size. Furthermore, the rs232_syscon module can share the Wishbone bus with the master (presumably a processor of some kind). It implements a handshaking protocol with the master to "request" the bus. When the master grants access, the rs232_syscon runs bus cycles on its own, to report contents of registers and memory back to the user, in an easy-to-read hexadecimal format. This is very useful when debugging peripherals -- you can set the contents of memory, set up registers, and even use registers to control "single stepping" of your target processor. If desired, the rs232_syscon can be the sole master of the Wishbone bus, to perform "human-speed" tests on peripherals (set a value, check a result) without having to connect the peripheral to a processor.
     <br/>
     The "ack_i" and "err_i" signals of the Wishbone bus are used to determine if the bus cycles are correctly executed. The rs232_syscon module uses a "watchdog" timer to determine if "ack_i" has arrived too late, and if so, it sends an error indicator back to the host terminal. If "err_i" occurs, it also sends back a bus error indicator. The timeout value of the watchdog timer is configurable by parameters to whatever length is needed, and the bus cycles are automatically extended for as many clocks as needed until the "ack_i" signal is received. If "ack_i" is not used, simply tie it high.
     <br/>
     The design team of rs232_syscon welcomes any kind of help and feedback on this core. If you are interested in further development of this project, please contact us.
     <br/>
    </p>
   </div>
   <div id="d_Status">
    <h2>
     
     
     Status
    </h2>
    <p id="p_Status">
     - This core now supports four basic commands: 'r' (read), 'w' (write), 'f' (fill) and 'i' (initialize = reset).
     <br/>
     - The read/write/fill commands allow a quantity field, to specify multiple writes or reads (using consecutive addresses).
     <br/>
     - There are no technology-dependent elements used in this core.
     <br/>
     - The data bus consists of separate dat_i/dat_o buses.
     <br/>
     - The core runs at clock speeds above 50MHz on a Lattice LFXP2-5E.
     <br/>
     - The interface is currently implemented as a large state-machine (no processor is involved.)
     <br/>
     - The command structure is very simple and "sparse."
     <br/>
     In the future, a version could be implemented using a small microcontroller core with some integrated software, which would probably be more compact and flexible, with a richer command set. But, since we wanted to use this core to _develop_ microcontroller cores -- well, it was a case of "which came first, the chicken or the egg?" We had to start somewhere!
     <br/>
    </p>
   </div>
   <div id="d_Project News">
    <h2>
     
     
     Project News
    </h2>
    <p id="p_Project News">
     - There is a new version of this module which incorporates "auto_baud_with_tracking".  It is a feature that allows for any FPGA board clock frequency from 1-100 MHz to be used for different BAUD rates.  There is no calculation needed, it adjusts automatically!
     <br/>
     - The rs232_syscon module has been used to build and debug a small microcontroller, the "risc16f84" project.
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
