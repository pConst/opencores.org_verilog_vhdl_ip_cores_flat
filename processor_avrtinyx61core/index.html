<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='avrtinyx61core.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: avrtinyx61core
    <br/>
    Created: Sep 14, 2008
    <br/>
    Updated: Nov 10, 2008
    <br/>
    SVN Updated: Mar 10, 2009
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Processor
    
    <br/>
    Language:
    
     VHDL
    
    <br/>
    Development status:
    
     Beta
    
    <br/>
    Additional info:
    
     Design done
    
    <br/>
    WishBone Compliant: No
    <br/>
    License: LGPL
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     This is a Atmel AVR ATtiny261/461/861 compatible core.
     <br/>
     It should be (more or less) fully code compliant, but it is not clock-cycle compliant.
     <br/>
     The reason it was developed was to have a simple core to develop C-code to.
     <br/>
     The implementation is rather strait forward without any pipelining.
     <br/>
     One reason was also to see how hard it was to implement a standard mcu in vhdl and make it run on gcc-generated code.
     <br/>
     The implementation is a bit quick-n-dirty, I spent about 15h coding the core and about 15h to writing test bench and simulate the core.
     <br/>
     I must also say that I'm an AVR fan, if designing hardware where you don't need a complete FPGA, just buy the AVR mcu directly from Atmel! http:\\www.atmel.com\avr
     <br/>
     Please note, you should not use the AVRStudio for development to this core, the files generated by AVRStudio is compatible with the core, BUT, if you don't buy the mcu from Atmel, you shouldn't use their software!
     <br/>
     The test bench uses code (C and Asm) compiled only with the help of gnu-tools.
     <br/>
     Atmel, AVR, AVRStudio and other names above may be trademarks of Atmel corporation.
     <br/>
    </p>
   </div>
   <div id="d_Info">
    <h2>
     
     
     Info
    </h2>
    <p id="p_Info">
     - Features:
     <br/>
     - Fully instruction compliant
     <br/>
     - Can address up to 64kword of instructions and 64kbyte of sram
     <br/>
     - Hex-file from a standard avr-gcc compile will work in this core
     <br/>
     - Difference to standard core:
     <br/>
     - The core is slow compared to original mcu, an instruction takes 3-6 cycles to execute
     <br/>
     - Tested:
     <br/>
     - With simple asm-code that tests all instructions
     <br/>
     - With a XTEA encryption/decryption algorithm to test math
     <br/>
     - Non tested:
     <br/>
     - Not all combinations of instructions, registers and constants are tested
     <br/>
     - hex2vhdl converter (may give wrong addresses)
     <br/>
     - Not implemented:
     <br/>
     - Writing of registers with ST, STS and STD (writing of sreg and sp might work)
     <br/>
     - Reading of registers with LD , LDS and LDD
     <br/>
     - SLEEP, WDR, SPM
     <br/>
     - IRQ
     <br/>
     - Future:
     <br/>
     - If you miss something in the core please just send me an email avmcu@opencores.org
     <br/>
     - My future plans is to optimize the core mostly for size but also for speed
     <br/>
     - Add generic to control number of address lines for PM and DM.
     <br/>
     - Add generic to skip SPH register
     <br/>
     - IRQ may be implemented in the future as a generic option if anybody requests it
     <br/>
     - Some simple io-units e.g. io-port, spi, uart, pwm and input-capture units
     <br/>
     - Add a wishbone bride for those who want to use wishbone components (if possible due to core clocking restrictions)
     <br/>
     - Some documentation of the core implementation
     <br/>
     - Add an example project that is ready to compile to an FPGA
     <br/>
     - Fixed in 2008-10-08 release: Add detection of unimplemented usage of LD/LDS/LDD/ST/STS/STD to indirect read or write register map (when X, Y or Z points to 0-0x1F). (Does gcc really use this anywhere?)
     <br/>
     - Wishes from me:
     <br/>
     - Please send me an email if you intend to test or use this core, send some information about your project or product. It would be nice to know if it will be used in any product.
     <br/>
     - Please don't forget to send me bug-reports, any bug fixes you do in the core must be released on the web anyway due to the lgpl license.
     <br/>
     - Comment about the testbench:
     <br/>
     - Fixed in 2008-10-08 release: tb_pm_hex is by default configured for max 2048 words (4096 bytes) of pm space, change generic g_pm_size to be able to use larger programs.
     <br/>
     - Fixed in 2008-10-08 release: the rjmp/rcall directly addresses the hole memory of up to 8 kBytes with "negative" addresses, this could give a error in the tb_pm_hex but does not effect real world applications. To fix simulation just use the lower 12 bits of the PM_A in tb_pm_hex/pm. "a_int := CONV_INTEGER(PM_A(11 downto 0));". If you use less then 4kBytes of pm code, then this problem will not be visible.
     <br/>
     - Other comments:
     <br/>
     - If you use this core in a project then please send me an email with a link to the projects home page so I could add a link to your project on this page.
     <br/>
     - If you modify the core you must make the changes available according to LGPL, just send me the link and I will add the link to this page or just send me a zip file that I could add to this page.
     <br/>
    </p>
   </div>
   <div id="d_Status">
    <h2>
     
     
     Status
    </h2>
    <p id="p_Status">
     - Mcu is ready and tested
     <br/>
     - Tb (with tb-source for core) is ready and tested
     <br/>
     - Extensive testing of core in real world not done
     <br/>
     - Synted (and par) for Xilinx Spartan3-400 with Ise 8.1, final results after place-and-route:
     <br/>
     - Optimized for speed: about 83 MHz, 150 ff, 1700 lut
     <br/>
     - Optimized for area: about 70 MHz, 130 ff, 1600 lut
     <br/>
     - Reported: Synted (and par) with Quartus, about 80% of a for Altera EP1C3.
     <br/>
     - Reported: One person have tested to implement a complete function with advanced mathematics in a Virtex E, no issues found so far with the core, in his application this core seems to run about 3.7-4 times slower (in cycle count) then a standard AVR.
     <br/>
     - The new release (2008-10-08) might be slightly larger (0.x%) but works better in simulation. There is no change to the cores instruction handling between first and this release.
     <br/>
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
