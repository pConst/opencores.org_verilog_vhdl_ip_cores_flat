<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='uart_fpga_slow_control.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: uart_fpga_slow_control
    <br/>
    Created: Aug 29, 2011
    <br/>
    Updated: Jul 16, 2012
    <br/>
    SVN Updated: Apr 11, 2012
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Communication controller
    
    <br/>
    Language:
    
     VHDL
    
    <br/>
    Development status:
    
     Stable
    
    <br/>
    Additional info:
    
     Design done
    
    ,
    
     FPGA proven
    
    ,
    
     Specification done
    
    <br/>
    WishBone Compliant: No
    <br/>
    License: LGPL
   </p>
   <div id="d_Block Diagram">
    <h2>
     
     
     Block Diagram
    </h2>
    <p id="p_Block Diagram">
     <img src="usercontent,img,1322058579" alt="uart_overview"/>
    </p>
   </div>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     <b>
      Control the activity and status of your FPGA by targeting a memory mapped space inside it.
     </b>
    </p>
    <p>
     <br/>
     Based on:
     <br/>
     <ul>
      <li>
       -- elements from the GH libraries (
       
        GH_library
       
       )
      </li>
      <li>
       -- HLeFevre UART project (
       
        LeFevre_uart
       
       )
      </li>
     </ul>
     <br/>
     Simple three steps access procedure:
     <ul>
      <li>
       -- Write words of 2 bytes address and 4 bytes data.
      </li>
      <li>
       -- Ask for an update targeting the update register (default 0x8000 0x00000000)
      </li>
      <li>
       -- Read words of 2 bytes address and 4 bytes data.
      </li>
     </ul>
     <br/>
     The code comes plug and play:
     <ul>
      <li>
       * the whole uart initialization process is automatic
      </li>
      <li>
       * 4 pins interface to the outsideworld: serial tx, serial rx, uart clock, hard reset
      </li>
      <li>
       * up to 2^16 32 bit wide registers for user logic control and monitor
      </li>
     </ul>
     <br/>
     Declare the registers you want to read and write in the top level entity:
     <ul>
      <li>
       + the rest will be handled automatically by FSMs.
      </li>
      <li>
       + almost no documentation is required.
      </li>
      <li>
       + no knowledge of the internals of the core required.
      </li>
      <li>
       + the top entity is self-explanatory.
      </li>
     </ul>
     <br/>
     Remotely control the logic from a PC:
     <ul>
      <li>
       ~ Under Windows use RealTerm to simply send and receive HEX commands (
       
        realterm.sourceforge.net
       
       ).
      </li>
      <li>
       ~ Simple Python script to drive the uart via command line in linux (see software details tab above).
      </li>
      <li>
       ~ TCP/IP to UART bridging is just around the corner using inexpensive external devices.
      </li>
     </ul>
     <br/>
     crossplatform compatible (tested on Xilinx Virtex-5 and Altera Stratix-4 devices).
     <br/>
     Tested up to 1 Mbps with a 29.4912 MHz oscillator.
     <br/>
     <b>
      ## Feeback:
     </b>
     <br/>
     &gt;&gt; Give comments and feedback using the official core thread on the OpenCores forum:
     <br/>
     
      forum_thread
     
     <br/>
     &gt;&gt; Tell us what you do with our core posting an answer in the bug tracker ticket below
     <br/>
     
      bug_tracker
     
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
