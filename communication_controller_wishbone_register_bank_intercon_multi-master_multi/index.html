<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='wrimm.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: wrimm
    <br/>
    Created: Jun 28, 2014
    <br/>
    Updated: Jul 27, 2014
    <br/>
    SVN Updated: Jul 28, 2014
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Communication controller
    
    <br/>
    Language:
    
     VHDL
    
    <br/>
    Development status:
    
     Beta
    
    <br/>
    Additional info:
    
     Design done
    
    ,
    
     FPGA proven
    
    <br/>
    WishBone Compliant: Yes
    <br/>
    License: BSD
   </p>
   <div id="d_Concept">
    <h2>
     
     
     Concept
    </h2>
    <p id="p_Concept">
     <img src="usercontent,img,1406480507" alt="BlockExample"/>
    </p>
   </div>
   <div id="d_Overview">
    <h2>
     
     
     Overview
    </h2>
    <p id="p_Overview">
    </p>
    <p>
     If your projects are like ours, you always need the capability to set configuration bits for internal components, or externally monitor the status of other components.  We have implemented this in many different ways across dozens of projects.  We hope Wrimm is the last time we re-develop this same functionality.
    </p>
    <p>
     Every new design needs a different set of registers.  Frequently improving an existing design requires adding or changing a register which also requires some level of re-development of the register logic.
    </p>
    <p>
     The goal of Wrimm is a fully tested logic block that doesn't change from design to design or during design revision.  Everything necessary to add and configure general purpose registers is contained in constant declarations in a VHDL package file.
    </p>
    <p>
     Along the way we also incorporated some other Wishbone functionality we frequently find useful.
    </p>
   </div>
   <div id="d_Capabilities">
    <h2>
     
     
     Capabilities
    </h2>
    <p id="p_Capabilities">
     <ul>
      <li>
       <b>
        Wishbone Support
       </b>
       - All the registers and other functions are readable and writeable via Wishbone compatible masters.
      </li>
      <li>
       <b>
        Parametric Wishbone Bus
       </b>
       - Wishbone address and data bus widths are configurable with a constant setting.
      </li>
      <li>
       <b>
        Glueless Interface
       </b>
       - Wishbone masters and slaves connect to Wrimm with the standard Wishbone Interface.  All required glue logic is automatically generated inside Wrimm.
      </li>
      <li>
       <b>
        Parametric Register Configuration
       </b>
       - The bit size and address locations for all the following register types are configurable in the project package file.  Register fields of different types may even share the same address (in different bit locations).
      </li>
      <li>
       <b>
        Setting Registers
       </b>
       - Setting registers offer  bit vector outputs to provide configuration to non-Wishbone modules.
      </li>
      <li>
       <b>
        Status Registers
       </b>
       - Status registers offer bit vector inputs to collect status information from non-Wishbone modules and provide that data via Wishbone reads.
      </li>
      <li>
       <b>
        Trigger Registers
       </b>
       - Trigger registers are single bit registers used to launch other non-Wishbone on-chip processes.  The triggers are then cleared by those functions.
      </li>
      <li>
       <b>
        Wishbone Record Type Interfaces
       </b>
       - The multi-signal wishbone interface is represented in two custom record types for a shorter, cleaner interface.
      </li>
      <li>
       <b>
        Multi Wishbone Master Support
       </b>
       - Any number of masters can be connected.  Round robbin arbitration is provided for all masters.
      </li>
      <li>
       <b>
        TBD- Multi Wishbone Slave Support
       </b>
       - Any number of wishbone slaves may be attached to the Wrimm component. Partial address decoding support is provided. Data, Ack, Rty, and Err signals are automatically muxed together to respond to the master with the grant.
      </li>
      <li>
       <b>
        TBD- Wishbone Reset Support
       </b>
       - Automatically drive Rst when requests go unanswered.
      </li>
      <li>
       <b>
        Adaptive Testbench
       </b>
       - Test bench also uses constant data from the package file to enable testing of the project specific configuration.
      </li>
      <li>
       <b>
        100% Synthesizeable VHDL
       </b>
       - All custom configuration is done in VHDL no other scripting language or intermediate compilation is required.
      </li>
     </ul>
    </p>
   </div>
   <div id="d_Documentation">
    <h2>
     
     
     Documentation
    </h2>
    <p id="p_Documentation">
    </p>
    <p>
     All documentation outside this brief description is contained in WrimmManual.pdf.
    </p>
   </div>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
    </p>
    <p>
     Wrimm provides Wishbone interconnect functionality, multi-master arbitration, multi-slave partial address deccoding and bus multiplexing.  Wrimm also incoporates configurable register bits for controlling and monitoring non-Wishbone functions.
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
