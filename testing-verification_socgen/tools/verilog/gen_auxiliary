eval 'exec `which perl` -S $0 ${1+"$@"}'
   if 0;
#/**********************************************************************/
#/*                                                                    */
#/*             -------                                                */
#/*            /   SOC  \                                              */
#/*           /    GEN   \                                             */
#/*          /    TOOL    \                                            */
#/*          ==============                                            */
#/*          |            |                                            */
#/*          |____________|                                            */
#/*                                                                    */
#/*                                                                    */
#/*                                                                    */
#/*                                                                    */
#/*  Author(s):                                                        */
#/*      - John Eaton, jt_eaton@opencores.org                          */
#/*                                                                    */
#/**********************************************************************/
#/*                                                                    */
#/*    Copyright (C) <2010-2011>  <Ouabache Design Works>              */
#/*                                                                    */
#/*  This source file may be used and distributed without              */
#/*  restriction provided that this copyright statement is not         */
#/*  removed from the file and that any derivative work contains       */
#/*  the original copyright notice and the associated disclaimer.      */
#/*                                                                    */
#/*  This source file is free software; you can redistribute it        */
#/*  and/or modify it under the terms of the GNU Lesser General        */
#/*  Public License as published by the Free Software Foundation;      */
#/*  either version 2.1 of the License, or (at your option) any        */
#/*  later version.                                                    */
#/*                                                                    */
#/*  This source is distributed in the hope that it will be            */
#/*  useful, but WITHOUT ANY WARRANTY; without even the implied        */
#/*  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR           */
#/*  PURPOSE.  See the GNU Lesser General Public License for more      */
#/*  details.                                                          */
#/*                                                                    */
#/*  You should have received a copy of the GNU Lesser General         */
#/*  Public License along with this source; if not, download it        */
#/*  from http://www.opencores.org/lgpl.shtml                          */
#/*                                                                    */
#/**********************************************************************/


############################################################################
# General PERL config
############################################################################
use Getopt::Long;
use English;
use File::Basename;
use Cwd;
use Scalar::Util qw(looks_like_number);
use XML::LibXML;
use lib './tools';
use sys::lib;
use yp::lib;
use BerkeleyDB;


$OUTPUT_AUTOFLUSH = 1; # set autoflush of stdout to TRUE.


############################################################################
### Process the options
############################################################################
Getopt::Long::config("require_order", "prefix=-");
GetOptions("h","help",
           "envidentifier=s" => \$envidentifier,
           "prefix=s" => \$prefix,
           "vendor=s" => \$vendor,
           "library=s" => \$library,
           "version=s" => \$version,
           "component=s" => \$component,
           "dest_dir=s" => \$dest_dir,
           "destination=s" => \$destination,
           "configuration=s" => \$configuration,
           "autodoc=s"   => \$autodoc,
           "fragment","no_port","local_parameters","tb","debug","verbose","interface_only","html","top"
) || die "(use '$program_name -h' for help)";


##############################################################################
## Help option
##############################################################################
if ( $opt_h  or $opt_help  ) 
  { print "\n gen_auxiliary -envidentifier {sim/syn}  -prefix /work -vendor vendor_name -library library_name  -component component_name  -version version_name -fragment -no_port -local_parameters -destination destination -configuration configuration -dest_dir  ../verilog";
    print "\n";
    exit 1;
  }

my $main_module_name = yp::lib::get_module_name($vendor,$library,$component,$version) ;

#############################################################################
## 
## 
#############################################################################

$home = cwd();



my $repo = yp::lib::find_component_repo($vendor,$library,$component) ;


my $variant;
my $view;


my $interface_in_count   =0;
my $interface_out_count  =0;
my $interface_in_size    =0;
my $interface_out_size   =0;

if($version)       {$variant   = "${component}_${version}";}
else               {$variant   = "${component}";}

unless($destination) { $destination = $variant;}
unless($autodoc)     { $autodoc     = "/Geda";}



print "---GEN_auxiliary -envidentifier $envidentifier  -prefix $prefix -vendor $vendor -library $library  -component $component  -version $version  -destination $destination -configuration $configuration -dest_dir  $dest_dir";


my $lib_comp_sep    = yp::lib::find_lib_comp_sep($vendor,$library,$component);
my $comp_xml_sep    = yp::lib::find_comp_xml_sep($vendor,$library,$component,$version);

my $parser = XML::LibXML->new();

my $socgen_file              = $parser->parse_file(yp::lib::find_componentConfiguration($vendor,$library,$component));
my $spirit_component_file    = $parser->parse_file(yp::lib::find_ipxact_component($vendor,$library,$component,$version));
my $doc_library_path         = $socgen_file->findnodes("//socgen:componentConfiguration/socgen:doc/socgen:library_path/text()")->to_literal;


my $sim_library_path ;

my $sim_comp_path            = $socgen_file->findnodes("//socgen:componentConfiguration/socgen:sim/socgen:comp_path/text()")->to_literal;

if ($sim_comp_path)  {$sim_library_path  ="${lib_comp_sep}${sim_comp_path}";}
else                 {$sim_library_path  = $socgen_file->findnodes("//socgen:componentConfiguration/socgen:sim/socgen:library_path/text()")->to_literal;}

foreach my $X_view ($spirit_component_file->findnodes('//spirit:component/spirit:model/spirit:views/spirit:view')) 
         {
         my($Xview_name)   = $X_view->findnodes('./spirit:name/text()')->to_literal ;
         my($Xview_envidentifier)   = $X_view->findnodes('./spirit:envIdentifier/text()')->to_literal ;


         if($envidentifier eq $Xview_envidentifier ) 
              { 
              $view = $Xview_name;
              }            
         } 


my $path  = "${home}${prefix}/${vendor}__${library}${lib_comp_sep}${component}${comp_xml_sep}/${dest_dir}";
mkdir $path,0755             unless( -e $path );

my $path  = "${home}${prefix}/${vendor}__${library}${lib_comp_sep}${component}${comp_xml_sep}/${dest_dir}/${view}";
mkdir $path,0755             unless( -e $path );

my   @filelist_hier     =       ();
my   @instantiations    =       ();
my   @parameters        =       ();
my   %parameter_values  =       ();
my   %parameter_descriptions  = ();




if($opt_tb )
{
   print "Creating testbench for   $vendor $library $component  $version \n";


   my $path  ="${home}${repo}/${vendor}/${library}${sim_library_path}";
   mkdir $path,0755             unless( -e $path );

   my $path  ="${home}${repo}/${vendor}/${library}${sim_library_path}/testbenches";
   mkdir $path,0755             unless( -e $path );

      $path  ="${home}${repo}/${vendor}/${library}${sim_library_path}/testbenches/xml";
   mkdir $path,0755             unless( -e $path );


   $outfile ="${home}${repo}/${vendor}/${library}${sim_library_path}/testbenches/xml/${variant}_dut.params.xml";
   open TB_COMP_FILE,">$outfile" or die "unable to open $outfile";

   print TB_COMP_FILE  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
   print TB_COMP_FILE  "<!--                                                \n";
   print TB_COMP_FILE  "//                                                //\n";
   print TB_COMP_FILE  "// Generated File Do Not EDIT                     //\n";
   print TB_COMP_FILE  "//                                                //\n";
   print TB_COMP_FILE  "// regen by adding -tb to gen_verilog script      //\n";
   print TB_COMP_FILE  "//                                                //\n";
   print TB_COMP_FILE  "-->                                                 \n";     
   print TB_COMP_FILE  "<spirit:component\n"; 
   print TB_COMP_FILE  "xmlns:spirit=\"http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009\"\n";
   print TB_COMP_FILE  "xmlns:socgen=\"http://opencores.org\"\n";
   print TB_COMP_FILE  "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
   print TB_COMP_FILE  "xsi:schemaLocation=\"http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009\n";
   print TB_COMP_FILE  "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009/index.xsd\">\n";
   print TB_COMP_FILE  "<spirit:vendor>${vendor}</spirit:vendor>\n";
   print TB_COMP_FILE  "<spirit:library>${library}</spirit:library>\n";
   print TB_COMP_FILE  "<spirit:name>${component}</spirit:name>\n";
   print TB_COMP_FILE  "<spirit:version>${version}_dut.params</spirit:version>\n";  


   $outfile ="${home}${repo}/${vendor}/${library}${sim_library_path}/testbenches/xml/${variant}_duth.design.xml";
   open TB_DESIGN_FILE,">$outfile" or die "unable to open $outfile";


   print TB_DESIGN_FILE  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
   print TB_DESIGN_FILE  "<!--                                                \n";
   print TB_DESIGN_FILE  "//                                                //\n";
   print TB_DESIGN_FILE  "// Generated File Do Not EDIT                     //\n";
   print TB_DESIGN_FILE  "//                                                //\n";
   print TB_DESIGN_FILE  "// regen by adding -tb to gen_verilog script      //\n";
   print TB_DESIGN_FILE  "//                                                //\n";
   print TB_DESIGN_FILE  "-->                                                 \n";     
   print TB_DESIGN_FILE  "<spirit:design\n"; 
   print TB_DESIGN_FILE  "xmlns:spirit=\"http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009\"\n";
   print TB_DESIGN_FILE  "xmlns:socgen=\"http://opencores.org\"\n";
   print TB_DESIGN_FILE  "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n";
   print TB_DESIGN_FILE  "xsi:schemaLocation=\"http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009\n";
   print TB_DESIGN_FILE  "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009/index.xsd\">\n";
   print TB_DESIGN_FILE  "<spirit:vendor>${vendor}</spirit:vendor>\n";
   print TB_DESIGN_FILE  "<spirit:library>${library}</spirit:library>\n";
   print TB_DESIGN_FILE  "<spirit:name>${component}</spirit:name>\n";
   print TB_DESIGN_FILE  "<spirit:version>${version}_dutg.design</spirit:version>\n";  

}
     #/**********************************************************************/
     #/*                                                                    */
     #/* if configuration set then read parameters from socgen:componentConfiguration file      */
     #/*                                                                    */
     #/**********************************************************************/

    if($configuration)
      {
      print "KKKKKKKKKK GEN_AUX $vendor  $library $component $version $configuration \n";
      # print "XXX Reading configuration   $configuration \n";
      unless ($socgen_file)      { print "No socgen ip file \n";};

      foreach my $socgen_cfg ($socgen_file->findnodes("//socgen:componentConfiguration/socgen:configurations/socgen:configuration/socgen:parameters/socgen:parameter/socgen:name")) 
                {
                my($param_name)         = $socgen_cfg->findnodes('./text()')->to_literal ;
                my($param_value)        = $socgen_cfg->findnodes('../socgen:value/text()')->to_literal ;
                my($config_name)        = $socgen_cfg->findnodes('../../../socgen:name/text()')->to_literal ;
                if($config_name eq $configuration  )
                  {
                  unless(defined $parameter_values{$param_name}) {push ( @parameters,  "$param_name");};
                  $parameter_values{$param_name} = ${param_value};
                  }
                }
     }

#/**********************************************************************/
#/*                                                                    */
#/* Every hier cell is constructed from the ipxact file with seperate  */
#/* version  for each view                                             */
#/*                                                                    */
#/* Start by opening the output file                                   */
#/* get fileset name                                                   */
#/* check that requested view exists                                   */
#/*                                                                    */
#/**********************************************************************/

foreach my $comp_view ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:views/spirit:view/spirit:name[text() = '$view']"             )) 
   {
   my($view_fileset_name)  = $comp_view->findnodes('../spirit:fileSetRef/spirit:localName/text()')->to_literal ;
   $outfile ="${home}${prefix}/${vendor}__${library}${lib_comp_sep}${component}${comp_xml_sep}/${dest_dir}/${view}/${destination}";
   open DEST_FILE,">$outfile" or die "unable to open $outfile";

# /* Test benches do not need to generate a io_ports database

   {
    my $io_ports_file = yp::lib::get_io_ports_db_filename($vendor,$library,$component,$version);
#    print "XXXXXXXX $io_ports_file  GEN_VERILOG  calling GEN_PORTS \n";
    $cmd = "./tools/verilog/gen_ports    -vendor $vendor -library $library  -component $component  -version $version  ";
    if (system($cmd)) {}
    $cmd = "./tools/verilog/gen_signals    -vendor $vendor -library $library  -component $component  -version $version  ";
     if (system($cmd)) {}


#    print "XXXXXXXX $io_ports_file  GEN_PORTS returning to GEN_VERILOG \n";
    $ports_db   = new BerkeleyDB::Hash( -Filename => $io_ports_file, -Flags => DB_CREATE ) or die "Cannot open ${io_ports_file}: $!";

   }


   unless ($opt_fragment){     print DEST_FILE  "\n module \n\n  $main_module_name \n ";}

   #/*****************************************************************************/
   #/*  wire_decs array holds all port and signal declarations                   */
   #/*  :::name:::node_input_output:::wire_reg:::scaler_vector:::left:::right::: */   
   #/*****************************************************************************/

   @wire_decs = (  );


   #/**********************************************************************/
   #/*  inst_conns holds all instance connections                         */
   #/**********************************************************************/

   @inst_conns = (  );

   my @decl_names  = (); 
   my %decl_dirs  = ();
   my %decl_types  = ();
   my %decl_vector = ();
   my %decl_lefts  = ();
   my %decl_rights = ();

   #  component file

   parse_component_file($spirit_component_file);
   if($opt_verbose){print "parse design files \n"; }
   parse_design_files($spirit_component_file);
   if($opt_verbose){print "process design files \n"; }
   process_design_files($spirit_component_file);
   if($opt_verbose){print "process wire_decs \n"; }

   #/**********************************************************************/
   #/*                                                                    */
   #/* pack ports and nodes into hashes                                   */
   #/*                                                                    */
   #/**********************************************************************/


   @wire_decs      = sys::lib::trim_sort(@wire_decs);
   foreach $line (@wire_decs)  
     { 
     $_ = $line;
        if(/:::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::/) 
          { 
          $q_index               = $1;
          $q_node_name           = $2;
          $q_direction           = $3;
          $q_type                = $4;
          $q_vector              = $5;        
          $q_left                = $6;        
          $q_right               = $7;
          $q_instance            = $8;
          $q_depth               = $9;
          $q_phy_name            = $10;
          $q_busref_name         = $11;          
          $q_abslog_name         = $12;          


  if($opt_debug ){print  "XXXXX--    $line \n  ";}

         push ( @decl_names,$q_index);


          if(  $decl_pnames{$q_index})
            {
            if(  $decl_pnames{$q_index} eq ${q_index})
              {
              $decl_pnames{$q_index}  = "${q_node_name}";
              }
            } 
          else
            {
            $decl_pnames{$q_index}  = "${q_node_name}";
            }


          if(  $decl_dirs{$q_index})
            {
            if(  $decl_dirs{$q_index} eq "node")
              {
              $decl_dirs{$q_index}  = "${q_direction}";
              }
            } 
          else
            {
            $decl_dirs{$q_index}  = "${q_direction}";
            }



            if(  $decl_types{$q_index})
              {
              if(  $decl_types{$q_index} eq "wire")
                {
                $decl_types{$q_index}  = "${q_type}";
                }
              } 
            else
              {
              $decl_types{$q_index}  = "${q_type}";
              }





          if(  $decl_vector{$q_index})
            {  unless(  $decl_vector{$q_index} eq "vector"){ $decl_vector{$q_index}  = "${q_vector}";  }} 
          else  { $decl_vector{$q_index}  = "${q_vector}"; }

          if( $q_vector eq "vector" )
            {
            if ( defined $decl_lefts{$q_index})
               {


                $_ = $q_left;
                if(/(\D+)/) 
                { 
                $_ = $decl_lefts{$q_index};
                   if(/(\D+)/) 
                   {
#                   print "Info:  $variant :: $q_node_name :    $q_left   is NOT  a number            $decl_lefts{$q_index}    is NOT  a number \n";
                   #if($decl_lefts{$q_index}   <= $q_left  ) {$decl_lefts{$q_index}   = $q_left;}
                   }
                   else
                   {
                   $decl_lefts{$q_index}   = $q_left;
                   }
                }
                else
 
                {
 
                $_ = $decl_lefts{$q_index};
                   if(/(\D+)/) 
                   {
                   #print "WARNING  $variant :: $q_node_name :    $q_left   is   a number            $decl_lefts{$q_index}    is NOT  a number \n";
                   #if($decl_lefts{$q_index}   <= $q_left  ) {$decl_lefts{$q_index}   = $q_left;}
                   }
                   else
                   {
                   #print "WARNING  $variant :: $q_node_name :    $q_left   is   a number            $decl_lefts{$q_index}    is   a number \n";
                   if($decl_lefts{$q_index}   <= $q_left  ) {$decl_lefts{$q_index}   = $q_left;}
                   }
                }
               unless (defined $decl_rights{$q_index})  {$decl_rights{$q_index}  = $q_right;}   
               if($decl_rights{$q_index}  >= $q_right ) {$decl_rights{$q_index}  = $q_right;}
               }
            else
               {
               $decl_lefts{$q_index}   = $q_left;
               $decl_rights{$q_index}  = $q_right;
               }
            }
          }
        }
     @decl_names      = sys::lib::trim_sort(@decl_names);





     #/**********************************************************************/
     #/*                                                                    */
     #/* All port and signal info is now loaded in hashes                   */
     #/* Resort on physical name                                            */
     #/* Print out module header , parameters and ports                     */
     #/*                                                                    */
     #/**********************************************************************/




   foreach my $decl_name (@decl_names)

     {

     my $phy_name = $decl_pnames{$decl_name};

     unless ($phy_name) {$phy_name =$decl_name }

     push ( @phy_names,$phy_name);


     if($opt_debug ){print  "XX-p   $decl_name - $decl_vector{$decl_name} -  $decl_lefts{$decl_name} - $decl_rights{$decl_name} --      $phy_name -   $phy_vector{$phy_name} - $phy_lefts{$phy_name} -  $phy_rights{$phy_name}  \n  ";}


     if(  $phy_dirs{$phy_name})
            {
            if(  $phy_dirs{$phy_name} eq "node")
              {
              $phy_dirs{$phy_name}   = "$decl_dirs{$decl_name}";
              }
            } 
          else
            {
            $phy_dirs{$phy_name}  = "$decl_dirs{$decl_name}";
            }

            if(  $phy_types{$phy_name})
              {
              if(  $phy_types{$phy_name} eq "wire")
                {
                $phy_types{$phy_name}  = "$decl_types{$decl_name}";
                }
              } 
            else
              {
              $phy_types{$phy_name}  = "$decl_types{$decl_name}";
              }

          if(  $phy_vector{$phy_name})
            {  unless(  $phy_vector{$phy_name} eq "vector"){ $phy_vector{$phy_name}  = "$decl_vector{$decl_name}";  }} 
          else  { $phy_vector{$phy_name}  = "$decl_vector{$decl_name}"; }

          if( $decl_vector{$decl_name} eq "vector" )
            {
            if ( defined $phy_lefts{$phy_name})
               {
                $_ = $phy_lefts{$phy_name};
                if(/(\D+)/) 
                { 
                $_ = $phy_lefts{$phy_name};
                   if(/(\D+)/) 
                   {
                   }
                   else
                   {
                   $phy_lefts{$phy_name}   = $decl_lefts{$decl_name};
                   }
                }
                else
                {
                $_ = $phy_lefts{$phy_name};
                   if(/(\D+)/) 
                   {
                   }
                   else
                   {
                   if($phy_lefts{$phy_name}   <= $decl_lefts{$decl_name}  ) {$phy_lefts{$phy_name}   = $decl_lefts{$decl_name};}
                   }
                }
               unless ( defined $phy_rights{$phy_name})                 {$phy_rights{$phy_name}  = $decl_rights{$decl_name};}
               if($phy_rights{$phy_name}  >= $decl_rights{$decl_name} ) {$phy_rights{$phy_name}  = $decl_rights{$decl_name};}
               }
            else
               {
               $phy_lefts{$phy_name}   = $decl_lefts{$decl_name};
               $phy_rights{$phy_name}  = $decl_rights{$decl_name};
               }
            }
     if($opt_debug ){print  "XX-q   $decl_name - $decl_vector{$decl_name} -  $decl_lefts{$decl_name} - $decl_rights{$decl_name} --      $phy_name -   $phy_vector{$phy_name} - $phy_lefts{$phy_name} -  $phy_rights{$phy_name}  \n  ";}    
      
   }


     @phy_names      = sys::lib::trim_sort(@phy_names);

     #/**********************************************************************/
     #/*                                                                    */
     #/* Add any and all global parameters with their default values        */
     #/*                                                                    */
     #/**********************************************************************/
      
     unless ($opt_local_parameters)
     {
     my $first = 1;
     foreach my $parameter_name (@parameters)  
        {
        my $parameter_value = $parameter_values{$parameter_name};
        if($first)
          {
          print DEST_FILE  "   #( parameter \n      ${parameter_name}=${parameter_value}";
          $first=0;
          }
        else  { print DEST_FILE  ",\n      ${parameter_name}=${parameter_value}";}
        }
      
     if    ($first == 0)   { print DEST_FILE  ")\n"; }
       }
      

     #/**********************************************************************/
     #/*                                                                    */
     #/* sort all  ports  with their type, size and direction               */
     #/*                                                                    */
     #/**********************************************************************/

     my @port_list  = (); 
     my @wire_nodes = ();
   {

       my $key;
       my $value;

       my $port_cursor = $ports_db->db_cursor() ;
        while ($port_cursor->c_get($key, $value, DB_NEXT) == 0) 
            {
            ( ${key_type},${busref},${conn}) = split( /\./ , $key);
            ( ${port_name},${direction},${type},${vector},${left},${right}) = split ':', $value;

            if( ($key  eq $port_name) and ($direction ne "node" )  )
              {
              print  DEST_FILE  "////   $key     ${port_name}    ${direction}        ${type} ${vector}   ${left}   ${right}  \n";
              my $q_width  = "     ";
              if( ${vector} eq "vector" )  { $q_width = "[ ${left} :  ${right}]";             }
              push (@port_list,  "${direction}   ${type}    $q_width        ${key}");       
              }
            }
     my $status = $port_cursor->c_close() ;


     @port_list      = sys::lib::trim_sort(@port_list);


     #/**********************************************************************/
     #/*                                                                    */
     #/* Now add all ports  with their type, size and direction             */
     #/*                                                                    */
     #/**********************************************************************/

     print DEST_FILE  "\n    ";
     $first = 1;
      
     foreach $port_line (@port_list)  
        {
          if($first)
            {
            print DEST_FILE  " (\n ${port_line}";
            $first=0;
            }
          else
            {
            print DEST_FILE  ",\n ${port_line}";
            }
          
        }

     if    ($first == 0)   { print DEST_FILE  ");\n\n\n\n"; }
     elsif ($opt_no_port)  { print DEST_FILE  "\n\n\n\n";  }
     else                  { print DEST_FILE  "();\n\n\n\n";}





     #/**********************************************************************/
     #/*                                                                    */
     #/* print wire decs for testbench                                      */
     #/*                                                                    */
     #/**********************************************************************/


     foreach $x_name (@phy_names)  
        {

        if( $phy_dirs{$x_name} ne "node" )                
          {
          if ( $phy_vector{$x_name} eq "vector" ) 
             {
             push (@tb_adhoc_list,  "<spirit:adHocConnection>\n<spirit:name>${x_name}<\/spirit:name>\n<spirit:externalPortReference spirit:portRef=\"${x_name}\" spirit:left=\"${phy_lefts{$x_name}}\" spirit:right=\"${phy_rights{$x_name}}\" \/>\n<spirit:internalPortReference  spirit:componentRef=\"dut\" spirit:portRef=\"${x_name}\" \/>\n<\/spirit:adHocConnection>\n"     );
             }
             else
            {
            push (@tb_adhoc_list,  "<spirit:adHocConnection>\n<spirit:name>${x_name}<\/spirit:name>\n<spirit:externalPortReference  spirit:portRef=\"${x_name}\" \/>\n<spirit:internalPortReference  spirit:componentRef=\"dut\" spirit:portRef=\"${x_name}\" \/>\n<\/spirit:adHocConnection>\n"     );
             }
         }
        }

     @tb_adhoc_list      = sys::lib::trim_sort(@tb_adhoc_list); 
     print TB_DESIGN_FILE  "<spirit:adHocConnections>\n\n";

     foreach $adhoc_line (@tb_adhoc_list)  
        {

            print TB_DESIGN_FILE  "${adhoc_line}\n";

          
        }

     print TB_DESIGN_FILE  "\n</spirit:adHocConnections>\n";






     #/**********************************************************************/
     #/*                                                                    */
     #/* interfaces for html                                                */
     #/*                                                                    */
     #/**********************************************************************/


     foreach $x_name (@phy_names)  
        {

        if( $phy_dirs{$x_name} ne "node" )                
          {

         my $interface_name;
         my $interface_description;

         foreach my $socgen_cfg ($socgen_file->findnodes("//socgen:componentConfiguration/socgen:doc/socgen:interfaces/socgen:interface/socgen:name[text() = '$x_name']")) 
             {
             $interface_description        = $socgen_cfg->findnodes('../socgen:description/text()')->to_literal ;   
             }

          if ( $phy_vector{$x_name} eq "vector" ) 
              { $interface_name  = "${x_name}[${phy_lefts{$x_name}}:${phy_rights{$x_name}} ]"  ; }
          else
              { $interface_name  = "${x_name}"; }


        if( $phy_dirs{$x_name} eq "input"  )  
          { $interface_in_count  = $interface_in_count  +1 ;
            if(length($interface_name)   >=  $interface_in_size  ){$interface_in_size = length($interface_name)  };
          };

        if( $phy_dirs{$x_name} eq "output" )  
          { $interface_out_count = $interface_out_count +1 ;
            if(length($interface_name)   >=  $interface_out_size  ){$interface_out_size = length($interface_name)  };

          };
        if( $phy_dirs{$x_name} eq "inout"  )  
          { 
          $interface_out_count = $interface_out_count +1 ;
            if(length($interface_name)   >=  $interface_out_size  ){$interface_out_size = length($interface_name)  };

          };







          push (@html_interface_list,"     <tr>  \n        <td style=\"vertical-align: top;\">${interface_name}<br>      </td>  \n       <td style=\"vertical-align: top;\">$phy_dirs{$x_name}<br>      </td>  \n       <td style=\"vertical-align: top;\">${interface_description}<br>      </td>  \n     </tr>  \n"  );

         }

        }

     #/**********************************************************************/
     #/*                                                                    */
     #/* Add parameters  to html file                                       */
     #/*                                                                    */
     #/**********************************************************************/

     foreach my $parameter_name (@parameters)  
        {
        my $parameter_value       = $parameter_values{$parameter_name};
        my $parameter_description = $parameter_descriptions{$parameter_name};
        push (@html_parameter_list,"   <tr> \n      <td style=\"vertical-align: top;\">${parameter_name}<br>      </td> \n          <td style=\"vertical-align: top;\">${parameter_value}<br>      </td> \n          <td style=\"vertical-align: top;\">${parameter_description}<br></td> \n         </tr> \n");
        }

     #/**********************************************************************/
     #/*                                                                    */
     #/* Add parameters  to dut      */
     #/*                                                                    */
     #/**********************************************************************/
print TB_DESIGN_FILE    "<spirit:componentInstances>\n\n";




print TB_DESIGN_FILE    "<spirit:componentInstance>\n";
print TB_DESIGN_FILE    "<spirit:instanceName>dut</spirit:instanceName>\n";
print TB_DESIGN_FILE    "<spirit:componentRef spirit:vendor=\"${vendor}\" spirit:library=\"${library}\" spirit:name=\"$component\" spirit:version=\"${version}\" />\n";
print TB_DESIGN_FILE    "<spirit:configurableElementValues>\n";


     foreach my $parameter_name (@parameters)  
        {
        print TB_DESIGN_FILE  " <spirit:configurableElementValue spirit:referenceId=\"${parameter_name}\">${parameter_name}<\/spirit:configurableElementValue>\n";
        }
      
print TB_DESIGN_FILE    "</spirit:configurableElementValues>\n";
print TB_DESIGN_FILE    "</spirit:componentInstance>\n";
print TB_DESIGN_FILE    "</spirit:componentInstances>\n";
print TB_DESIGN_FILE    "</spirit:design>\n";




     #/**********************************************************************/
     #/*                                                                    */
     #/* Add parameters  to comp      */
     #/*                                                                    */
     #/**********************************************************************/
print TB_COMP_FILE    "<spirit:model>\n\n";
print TB_COMP_FILE    "      <spirit:views>                                            \n";  
print TB_COMP_FILE    "                                   \n";  
print TB_COMP_FILE    "              <spirit:view>                                   \n";  
print TB_COMP_FILE    "              <spirit:name>Dut</spirit:name>                                   \n";  
print TB_COMP_FILE    "              <spirit:envIdentifier></spirit:envIdentifier>                                   \n";  
print TB_COMP_FILE    "              <spirit:hierarchyRef spirit:vendor=\"${vendor}\"                                    \n";  
print TB_COMP_FILE    "                                   spirit:library=\"${library}\"                                    \n";  
print TB_COMP_FILE    "                                   spirit:name=\"${component}\"                                    \n";  
print TB_COMP_FILE    "                                   spirit:version=\"${version}_dutg.design\"/>                                   \n";  
print TB_COMP_FILE    "              </spirit:view>                                   \n";  
print TB_COMP_FILE    "      </spirit:views>                                   \n";  
print TB_COMP_FILE    "<spirit:modelParameters>\n";





     foreach my $parameter_name (@parameters)  
        {
        my $parameter_value = $parameter_values{$parameter_name};
        print TB_COMP_FILE  "    <spirit:modelParameter><spirit:name>${parameter_name}</spirit:name><spirit:value>${parameter_value}</spirit:value></spirit:modelParameter>\n";
        }
      
        print TB_COMP_FILE    "</spirit:modelParameters>\n";
        print TB_COMP_FILE    "</spirit:model>\n";
        print TB_COMP_FILE  "</spirit:component>\n";


if($opt_html )
{
   print "Creating documentation for   $vendor $library $component  $version \n";
   my $path  ="${home}${repo}/${vendor}/${library}${doc_library_path}";
   mkdir $path,0755             unless( -e $path );


   my $path  ="${home}${repo}/${vendor}/${library}${doc_library_path}${autodoc}";
   mkdir $path,0755             unless( -e $path );



      $path  ="${home}${repo}/${vendor}/${library}${doc_library_path}${autodoc}/html";
   mkdir $path,0755             unless( -e $path );

      $path  ="${home}${repo}/${vendor}/${library}${doc_library_path}/html";
   mkdir $path,0755             unless( -e $path );



   $outfile ="${home}${repo}/${vendor}/${library}${doc_library_path}/html/${main_module_name}.html";

  unless( -e $outfile )
    {
    my $cmd = "cp  ${home}/tools/documentation/template.html   $outfile      ";
    if (system($cmd)) {}
    };

   $outfile ="${home}${repo}/${vendor}/${library}${doc_library_path}${autodoc}/html/${main_module_name}.html";
   open HTML_FILE,">$outfile" or die "unable to open $outfile";


   print HTML_FILE  " <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">  \n";
   print HTML_FILE  " <html>  \n";
   print HTML_FILE  " <head>  \n";
   print HTML_FILE  "   <meta http-equiv=\"CONTENT-TYPE\" content=\"text/html; charset=utf-8\">  \n";
   print HTML_FILE  "   <title>start</title>  \n";
   print HTML_FILE  "   <meta name=\"GENERATOR\" content=\"OpenOffice.org 3.0  (Linux)\">  \n";
   print HTML_FILE  "   <meta name=\"CREATED\" content=\"0;0\">  \n";
   print HTML_FILE  "   <meta name=\"CHANGED\" content=\"20090513;8521600\">  \n";
   print HTML_FILE  "   <meta name=\"KEYWORDS\" content=\"start\">  \n";
   print HTML_FILE  "   <meta name=\"Info 3\" content=\"\">  \n";
   print HTML_FILE  "   <meta name=\"Info 4\" content=\"\">  \n";
   print HTML_FILE  "   <meta name=\"date\" content=\"2008-01-08T12:01:41-0500\">  \n";
   print HTML_FILE  "   <meta name=\"robots\" content=\"index,follow\">  \n";
   print HTML_FILE  " </head>  \n";
   print HTML_FILE  " <body dir=\"ltr\" lang=\"en-US\">  \n";
   print HTML_FILE  " <h1><a name=\"${main_module_name}\"></a>SOCGEN Datasheet:<br>  \n";
   print HTML_FILE  " </h1>  \n";
   print HTML_FILE  " <div id=\"toc__inside\" dir=\"ltr\">  \n";
   print HTML_FILE  " <ul>  \n";
   print HTML_FILE  "   <li>  \n";
   print HTML_FILE  "     <p style=\"margin-bottom: 0in;\"><a href=\"#${main_module_name}\">${main_module_name}<br>  \n";
   print HTML_FILE  "     </a></p>  \n";

   foreach my $socgen_cfg ($socgen_file->findnodes("//socgen:componentConfiguration/socgen:doc/socgen:versions/socgen:version/socgen:name[text() = '$version']")) 
             {
             $module_description        = $socgen_cfg->findnodes('../socgen:description/text()')->to_literal ;
             }
   print HTML_FILE  " <br>  \n";
   print HTML_FILE  " <br>  $module_description         \n";
   print HTML_FILE  " <br>  \n";

   print HTML_FILE  "       <li>  \n";
   print HTML_FILE  "         <p><a href=\"../src/${main_module_name}.v\">SourceCode <br>  \n";
   print HTML_FILE  "         </a></p>  \n";
   print HTML_FILE  "       </li>  \n";


   print HTML_FILE  "       <li>  \n";
   print HTML_FILE  "         <p style=\"margin-bottom: 0in;\"><a href=\"#Parameters\">Parameters<br>  \n";
   print HTML_FILE  "         </a></p>  \n";
   print HTML_FILE  "       </li>  \n";

   print HTML_FILE  "       <li>  \n";
   print HTML_FILE  "         <p style=\"margin-bottom: 0in;\"><a href=\"#Interface\">Interface<br>  \n";
   print HTML_FILE  "         </a></p>  \n";
   print HTML_FILE  "       </li>  \n";


   print HTML_FILE  "       <li>  \n";
   print HTML_FILE  "         <p style=\"margin-bottom: 0in;\"><a href=\"#Children\">Children<br>  \n";
   print HTML_FILE  "         </a></p>  \n";
   print HTML_FILE  "       </li>  \n";



   print HTML_FILE  "       <li>  \n";
   print HTML_FILE  "         <p><a href=\"../../html/${main_module_name}.html#TheoryofOperation\">Theory of Operation<br>  \n";
   print HTML_FILE  "         </a></p>  \n";
   print HTML_FILE  "       </li>  \n";


   print HTML_FILE  "     </ul>  \n";
   print HTML_FILE  "   </li>  \n";
   print HTML_FILE  " </ul>  \n";
   print HTML_FILE  " </div>  \n";

   if($interface_in_count >= $interface_out_count) {$max_lines = $interface_in_count }
   else  {$max_lines = $interface_out_count }

   $scale = 1.0000;
   $max_lines =(($max_lines *24)+110)* $scale;
   $max_width = $interface_in_size +  $interface_out_size;
   $max_width =(($max_width * 10) + 343) * $scale ;

   print HTML_FILE  " <img style=\"width: ${max_width}px; height: ${max_lines}px;\" alt=\"\"  src=\"../png/${main_module_name}_sym.png\"><br>  \n";
   print HTML_FILE  " <b><br>  \n";

   print HTML_FILE  " <h2><b><a name=\"Parameters\"></a>Parameters<br></b></h2>  \n";
   print HTML_FILE  " <b><br>  \n";
   print HTML_FILE  " <br>  \n";
   print HTML_FILE  " </b>  \n";
   print HTML_FILE  "<table style=\"text-align: left; width: 640px; height: 120px;\" border=\"8\" cellpadding=\"4\" cellspacing=\"4\"> \n";
   print HTML_FILE  "  <tbody> \n";

   print HTML_FILE  "   <tr> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Name<br>      </td> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">default <br>      </td> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Description<br></td> \n";
   print HTML_FILE  "    </tr> \n";



     foreach $html_line (@html_parameter_list)  
        {
        print HTML_FILE  "${html_line}\n";
        }



   print HTML_FILE  "   </tbody>  \n";
   print HTML_FILE  "  </table>  \n";
   print HTML_FILE  " <p><b><b><br>  \n";
   print HTML_FILE  " </b></b></p>  \n";
   print HTML_FILE  " <p><br>  \n";
   print HTML_FILE  " </p>  \n";
   print HTML_FILE  " <p><b><b><br>  \n";
   print HTML_FILE  " </b></b></p>  \n";
   print HTML_FILE  " <p><b><b><br>  \n";

   print HTML_FILE  " <br>  \n";
   print HTML_FILE  " </b></b></p>  \n";

   print HTML_FILE  " <h2><b><b><a name=\"Interface\"></a>Interface</b><b>&nbsp;<br>  \n";
   print HTML_FILE  " </b></b></h2>  \n";
   print HTML_FILE  " <p style=\"margin-bottom: 0in;\"></p>  \n";
   print HTML_FILE  " <br>  \n";
   print HTML_FILE  " <br>  \n";
   print HTML_FILE  " <br>  \n";


   print HTML_FILE  " <table style=\"text-align: left; width: 640px; height: 120px;\" border=\"8\"  \n";
   print HTML_FILE  "  cellpadding=\"4\" cellspacing=\"4\">  \n";
   print HTML_FILE  "   <tbody>  \n";
   print HTML_FILE  "     <tr>  \n";
   print HTML_FILE  "       <td style=\"vertical-align: top;\">NAME<br>      </td>  \n";
   print HTML_FILE  "       <td style=\"vertical-align: top;\">Type<br>      </td>  \n";
   print HTML_FILE  "       <td style=\"vertical-align: top;\">Description<br>      </td>  \n";
   print HTML_FILE  "     </tr>  \n";
     foreach $html_line (@html_interface_list)  
        {
        print HTML_FILE  "${html_line}\n";    
        }
   print HTML_FILE  "   </tbody>  \n";
   print HTML_FILE  "  </table>  \n";
   print HTML_FILE  " <p><b><b><br>  \n";
   print HTML_FILE  " </b></b></p>  \n";



   print HTML_FILE  " <h2><b><a name=\"Children\"></a>Children<br></b></h2>  \n";
   print HTML_FILE  " <b><br>  \n";
   print HTML_FILE  " </b>  \n";
   print HTML_FILE  "<table style=\"text-align: left; width: 640px; height: 120px;\" border=\"8\" cellpadding=\"4\" cellspacing=\"4\"> \n";
   print HTML_FILE  "  <tbody> \n";

   print HTML_FILE  "   <tr> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Instance<br>      </td> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Vendor<br>      </td> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Library<br></td> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Component<br></td> \n";
   print HTML_FILE  "      <td style=\"vertical-align: top;\">Version<br></td> \n";
   print HTML_FILE  "    </tr> \n";

     my @spirit_design_files       = yp::lib::find_ipxact_design_files($vendor,$library,$component,$version);

     foreach  my   $sd_file (@spirit_design_files)
     {

     $_ = $sd_file;
        if(/:::(\S+):::(\S+):::(\S+):::(\S+):::/) 
          { 
          $q_vendor            = $1;
          $q_library           = $2;
          $q_design            = $3;
          $q_version           = $4;
          $sd_file             = $parser->parse_file(yp::lib::find_ipxact_design($q_vendor,$q_library,$q_design,$q_version));
          }
                  
          foreach  my   $x_name ($sd_file->findnodes("//spirit:design/spirit:componentInstances/spirit:componentInstance/spirit:instanceName"))
            {
            #/**********************************************************************/
            #/*                                                                    */
            #/* Lookup VLNV for each instantiated component                        */
            #/*                                                                    */
            #/**********************************************************************/


           my($instance_name)       = $x_name ->findnodes('./text()')->to_literal ;
           my($vendor_name)         = $x_name  ->findnodes('../spirit:componentRef/@spirit:vendor')->to_literal ;
           my($library_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:library')->to_literal ;
           my($component_name)      = $x_name  ->findnodes('../spirit:componentRef/@spirit:name')->to_literal ;
           my($version_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:version')->to_literal ;

           print HTML_FILE  "   <tr> \n";
           print HTML_FILE  "      <td style=\"vertical-align: top;\">$instance_name<br>      </td> \n";
           print HTML_FILE  "      <td style=\"vertical-align: top;\">$vendor_name<br>      </td> \n";
           print HTML_FILE  "      <td style=\"vertical-align: top;\">$library_name<br></td> \n";
           print HTML_FILE  "      <td style=\"vertical-align: top;\">$component_name<br></td> \n";
           print HTML_FILE  "      <td style=\"vertical-align: top;\">$version_name<br></td> \n";
           print HTML_FILE  "    </tr> \n";
           }    
     }

     print HTML_FILE  "   </tbody>  \n";
     print HTML_FILE  "  </table>  \n";
     print HTML_FILE  " <p><b><b><br>  \n";
     print HTML_FILE  " </b></b></p>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <img style=\"width: ${max_width}px; height: ${max_lines}px;\" alt=\"\"  src=\"../png/${main_module_name}_sch.png\"><br>  \n";
     print HTML_FILE  " <b><br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " <br>  \n";
     print HTML_FILE  " </body>  \n";
     print HTML_FILE  " </html>  \n";
}

     #/**********************************************************************/
     #/*                                                                    */
     #/* Add any and all local parameters with their default values         */
     #/*                                                                    */
     #/**********************************************************************/
      
     if ($opt_local_parameters)
     {
     foreach my $parameter_name (@parameters)  
        {
        my $parameter_value = $parameter_values{${parameter_name}};
        print DEST_FILE  "parameter ${parameter_name} = ${parameter_value};\n";
        }
     }

     #/**********************************************************************/
     #/*                                                                    */
     #/* Add all internal wires and regs with their sizes                   */
     #/*                                                                    */
     #/**********************************************************************/
   
       my $port_cursor = $ports_db->db_cursor() ;
        while ($port_cursor->c_get($key, $value, DB_NEXT) == 0) 
            {
            ( ${key_type},${busref},${conn}) = split( /\./ , $key);
            ( ${port_name},${direction},${type},${vector},${left},${right}) = split ':', $value;

            if( ($key  eq $port_name) and ($direction eq "node" )  )
              {
              my $q_width  = "     ";
              if( ${vector} eq "vector" )   { $q_width = "[ $left :  $right]";}
              if( $direction eq "node" )    { push @wire_nodes,     "$type     $q_width              ${port_name};";}
              }
            }

       my $status = $port_cursor->c_close() ;
   }

     @wire_nodes      = sys::lib::trim_sort(@wire_nodes);

     unless ($opt_interface_only)
     {
     foreach my $wire_node (@wire_nodes)
     {
     print DEST_FILE  "${wire_node}\n";
     }

     print DEST_FILE  "\n\n\n";
     while(   my $line_out      = shift(@instantiations))             {  print DEST_FILE  "$line_out";}


     #/**********************************************************************/
     #/*                                                                    */
     #/* After all the data from the ip-xact file has been entered we now   */
     #/* insert any and all verilog fragments at the end before closing     */
     #/* the module                                                         */
     #/*                                                                    */
     #/**********************************************************************/
      
      
     foreach  my   $i_name ($spirit_component_file->findnodes("//spirit:fileSets/spirit:fileSet/spirit:file/spirit:name"))
        {
        my($rtl_file)       = $i_name ->findnodes('./text()')->to_literal;
        my($file_type)      = $i_name ->findnodes('../spirit:userFileType/text()')->to_literal;
        my($view_file)      = $i_name ->findnodes('../../spirit:name/text()')->to_literal ;
 
        if(($file_type eq "fragment")&& (($view_file eq $view_fileset_name)))
          {
          $SRCFILE ="${home}${prefix}/${vendor}__${library}${lib_comp_sep}${component}${comp_xml_sep}/${rtl_file}";
          open(SRCFILE) or die("Could not open src file.  $SRCFILE ");
          foreach $line (<SRCFILE>) 
             {
             chomp($line);   
             print DEST_FILE  "${line}\n";
             }
          }
        }
      }
     unless ($opt_fragment ) {print DEST_FILE  "\n\n\n  endmodule\n\n";}   
     
   }











#/*********************************************************************************************/
#/                                                                                            */
#/ this routine does not follow busses down into componentRef                                 */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/*********************************************************************************************/




sub parse_busInterface 
   {
   my @params     = @_;
   my $depth      = pop(@params);
   my $busref     = pop(@params);
   my $version    = pop(@params);
   my $component  = pop(@params);
   my $library    = pop(@params);
   my $vendor     = pop(@params);

   my $home = cwd();

   my @out_stack  = ();

  if($opt_verbose){print "parse_busInterface $vendor $library $component $version \n"; }



   my $busInterfaceTest = 0;




my  @filelist =       yp::lib::parse_component_brothers("$vendor","$library","$component","$version");

foreach $line (@filelist) 
   {
   $_ = $line;
   if(/::(\S+)::(\S+)::(\S+)::(\S+)::/) 
     { 
     $new_library        = $2;
     $new_component      = $3;
     $new_vendor         = $1;
     $new_version        = $4;                

#     print " FFFFFFFFFFFFFFFF  Brother      $new_vendor  $new_library  $new_component $new_version \n" ;

    my $spirit_component_file    = $parser->parse_file(yp::lib::find_ipxact_component($new_vendor,$new_library,$new_component,$new_version));


   my @mas_slave;
     push @mas_slave  , "master"; 
     push @mas_slave  , "slave"; 

     foreach my $seek_type (@mas_slave) 
        { 

#print  "XXXXCX   Component $new_vendor $new_library $new_component $new_version  $seek_type \n";

     foreach my $bus_iface ($spirit_component_file->findnodes("//spirit:component/spirit:busInterfaces/spirit:busInterface/spirit:${seek_type}")) 
        {
        my($fff_cname)         = $bus_iface->findnodes('../spirit:name/text()')->to_literal ;
        my($fff_vendor)        = $bus_iface->findnodes('../spirit:abstractionType/@spirit:vendor')->to_literal ;
        my($fff_library)       = $bus_iface->findnodes('../spirit:abstractionType/@spirit:library')->to_literal ;
        my($fff_name)          = $bus_iface->findnodes('../spirit:abstractionType/@spirit:name')->to_literal ;
        my($fff_version)       = $bus_iface->findnodes('../spirit:abstractionType/@spirit:version')->to_literal ;


       if( $busref eq   $fff_cname )
         {
        my $absDef_filename = yp::lib::get_absDef_db_filename($fff_vendor,$fff_library,$fff_name,$fff_version);
        $absDef_db   = new BerkeleyDB::Hash( -Filename => $absDef_filename, -Flags => DB_CREATE ) or die "Cannot open ${absDef_filename}: $!";


        foreach my $port_face ($spirit_component_file->findnodes('//spirit:component/spirit:busInterfaces/spirit:busInterface/spirit:portMaps/spirit:portMap/spirit:logicalPort')) 
           {
           my($fff_log_name)      = $port_face->findnodes('./spirit:name/text()')->to_literal ;
           my($fff_int_name)      = $port_face->findnodes('../../../spirit:name/text()')->to_literal ;
           my($fff_phy_name)      = $port_face->findnodes('../spirit:physicalPort/spirit:name/text()')->to_literal ;
           my($fff_type_name)     = $port_face->findnodes('../spirit:physicalPort/spirit:wireTypeDefs/spirit:wireTypeDef/spirit:typeName/text()')->to_literal ;
           my($fff_left_value)    = $port_face->findnodes('../spirit:physicalPort/spirit:wire/spirit:vector/spirit:left/text()')->to_literal ;
           my($fff_right_value)   = $port_face->findnodes('../spirit:physicalPort/spirit:wire/spirit:vector/spirit:right/text()')->to_literal ;

           unless ($fff_type_name)  {$fff_type_name = "wire";};



           my $abs_data;
           $absDef_db->db_get("${seek_type}__${fff_log_name}", $abs_data );

           ( $berk_name, $berk_presence,$berk_width,$fff_direction ) = split ':', $abs_data;

           if(  ( $fff_int_name  eq  $busref)     )
             {
             $busInterfaceTest = 1;
#             print "XXXCXX $fff_log_name $seek_type  $fff_direction  \n";

                  if($fff_left_value ne "") 
                    { push @out_stack, ":::${depth}:::${fff_log_name}:::${fff_phy_name}:::${fff_direction}:::${fff_type_name}:::vector:::${fff_left_value}:::${$fff_right_value}:::"; }
                  else              
                    { push @out_stack, ":::${depth}:::${fff_log_name}:::${fff_phy_name}:::${fff_direction}:::${fff_type_name}:::scaler:::none:::none:::";    }                  
                

             }

           }

#       print "XXXCXX CLOSE  ${fff_vendor}_${fff_library}_${fff_name}_${fff_version}  \n";






       $absDef_db->db_close();              

      }






       }   

}


}

}


       if ( $busInterfaceTest){
                              @out_stack      = sys::lib::trim_sort(@out_stack);      
                              return(@out_stack);
                              }


     my @spirit_design_files       = yp::lib::find_ipxact_design_files($vendor,$library,$component,$version);

     foreach  my   $sd_file (@spirit_design_files)
     {

     $_ = $sd_file;
        if(/:::(\S+):::(\S+):::(\S+):::(\S+):::/) 
          { 
          $q_vendor            = $1;
          $q_library           = $2;
          $q_design            = $3;
          $q_version           = $4;
          $sd_file             = $parser->parse_file(yp::lib::find_ipxact_design($q_vendor,$q_library,$q_design,$q_version));
          }

     foreach  my   $x_name ($sd_file->findnodes('//spirit:hierConnections/spirit:hierConnection/@spirit:interfaceRef'))
        {
        my($hierConn_name)                   = $x_name ->to_literal ;
        my($hierConn_comref_name)            = $x_name ->findnodes('../spirit:interface/@spirit:componentRef')->to_literal ;
        my($hierConn_busref_name)            = $x_name ->findnodes('../spirit:interface/@spirit:busRef')->to_literal ;
        if($busref eq  $hierConn_name)   
          {
          foreach  my   $x_name ($sd_file->findnodes("//spirit:design/spirit:componentInstances/spirit:componentInstance/spirit:instanceName[text() = '$hierConn_comref_name']"))
            {
            #/**********************************************************************/
            #/*                                                                    */
            #/* Lookup VLNV for each instantiated component                        */
            #/*                                                                    */
            #/**********************************************************************/

            my($vendor_name)         = $x_name  ->findnodes('../spirit:componentRef/@spirit:vendor')->to_literal ;
            my($library_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:library')->to_literal ;
            my($component_name)      = $x_name  ->findnodes('../spirit:componentRef/@spirit:name')->to_literal ;
            my($version_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:version')->to_literal ;
            $depth = $depth +1;
            @out_stack = parse_busInterface ($vendor_name, $library_name,$component_name,$version_name,$hierConn_busref_name,$depth );
            }
          }
        }

     }




        @out_stack      = sys::lib::trim_sort(@out_stack);      
        return(@out_stack);
     

   }














#/*********************************************************************************************/
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/*********************************************************************************************/




sub parse_design_files
   {
   my @params     = @_;
   my $spirit_component_file      = pop(@params);

   #print "\n";






  foreach my $new_comp ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:views/spirit:view/spirit:vendorExtensions/spirit:componentRef")) 
    {
            my($new_vendor)        = $new_comp->findnodes('./@spirit:vendor')->to_literal ;
            my($new_library)       = $new_comp->findnodes('./@spirit:library')->to_literal ;
            my($new_name)          = $new_comp->findnodes('./@spirit:name')->to_literal ;
            my($new_version)       = $new_comp->findnodes('./@spirit:version')->to_literal ;
            parse_design_files($parser->parse_file(yp::lib::find_ipxact_component($new_vendor,$new_library,$new_name,$new_version )) );
   }




  foreach my $new_comp ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:views/spirit:view/spirit:hierarchyRef")) 
    {
            my($new_vendor)        = $new_comp->findnodes('./@spirit:vendor')->to_literal ;
            my($new_library)       = $new_comp->findnodes('./@spirit:library')->to_literal ;
            my($new_name)          = $new_comp->findnodes('./@spirit:name')->to_literal ;
            my($new_version)       = $new_comp->findnodes('./@spirit:version')->to_literal ;
            if(yp::lib::find_ipxact_design($new_vendor,$new_library,$new_name,$new_version ))
              {
              parse_design_file($parser->parse_file(yp::lib::find_ipxact_design($new_vendor,$new_library,$new_name,$new_version )) );
              }





  }

}







#/*********************************************************************************************/
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/*********************************************************************************************/




sub process_design_files
   {
   my @params     = @_;
   my $spirit_component_file      = pop(@params);

   #print "\n";







  foreach my $new_comp ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:views/spirit:view/spirit:vendorExtensions/spirit:componentRef")) 
    {
            my($new_vendor)        = $new_comp->findnodes('./@spirit:vendor')->to_literal ;
            my($new_library)       = $new_comp->findnodes('./@spirit:library')->to_literal ;
            my($new_name)          = $new_comp->findnodes('./@spirit:name')->to_literal ;
            my($new_version)       = $new_comp->findnodes('./@spirit:version')->to_literal ;
            process_design_files($parser->parse_file(yp::lib::find_ipxact_component($new_vendor,$new_library,$new_name,$new_version )) );
    }






  foreach my $new_comp ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:views/spirit:view/spirit:hierarchyRef")) 
    {
            my($new_vendor)        = $new_comp->findnodes('./@spirit:vendor')->to_literal ;
            my($new_library)       = $new_comp->findnodes('./@spirit:library')->to_literal ;
            my($new_name)          = $new_comp->findnodes('./@spirit:name')->to_literal ;
            my($new_version)       = $new_comp->findnodes('./@spirit:version')->to_literal ;
            if( yp::lib::find_ipxact_design($new_vendor,$new_library,$new_name,$new_version )  )
              {
              if($opt_verbose){print "process_design_file  $new_vendor $new_library $new_name $new_version  \n"; }
              process_design_file($parser->parse_file(yp::lib::find_ipxact_design($new_vendor,$new_library,$new_name,$new_version )) );
              }
    }

}










#/*********************************************************************************************/
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/*********************************************************************************************/




sub parse_design_file
   {
   my @params     = @_;
   my $spirit_design_file      = pop(@params);





#print "\n";
foreach my $new_comp ($spirit_design_file->findnodes("//spirit:design/spirit:vendor")) 
   {
   my($new_vendor)          = $new_comp->findnodes('./text()')->to_literal ;
   my($new_library)         = $new_comp->findnodes('../spirit:library/text()')->to_literal ;
   my($new_name)            = $new_comp->findnodes('../spirit:name/text()')->to_literal ;
   my($new_version)         = $new_comp->findnodes('../spirit:version/text()')->to_literal ;
   #print "WARNING  $new_vendor $new_library $new_name $new_version  DESIGN \n";
   }




     #/**********************************************************************/
     #/*                                                                    */
     #/* Add all internal wires and regs with their sizes                   */
     #/*                                                                    */
     #/**********************************************************************/
          
     foreach  my   $i_name ($spirit_design_file->findnodes("//spirit:design/spirit:vendorExtensions/socgen:nodes/socgen:node/spirit:name"))
        {
        my($node_name)       = $i_name ->findnodes('./text()')->to_literal ;
        my($node_busdef)     = $i_name ->findnodes('../socgen:busDef/text()')->to_literal ;
        my($node_left)       = $i_name ->findnodes('../spirit:wire/spirit:vector/spirit:left/text()')->to_literal ;
        my($node_right)      = $i_name ->findnodes('../spirit:wire/spirit:vector/spirit:right/text()')->to_literal ; 
        my($node_type)       = $i_name ->findnodes('../spirit:typeName/text()')->to_literal ;
      
        unless($node_busdef){   $node_busdef =    $node_name;     }

        if(  $node_left ne "" ) { push @wire_decs , ":::${node_busdef}:::${node_name}:::node:::${node_type}:::vector:::${node_left}:::${$node_right}:::none:::0:::${node_name}:::XXX:::${node_name}:::"; }
        else                     { push @wire_decs , ":::${node_busdef}:::${node_name}:::node:::${node_type}:::scaler:::none:::none:::none:::0:::${node_name}:::XXX:::${node_name}:::";   }

        }








     #/**********************************************************************/
     #/*                                                                    */
     #/* Read each hierConnection and enter signals into wire_decs          */
     #/*                                                                    */
     #/**********************************************************************/
     foreach  my   $x_name ($spirit_design_file->findnodes('//spirit:hierConnections/spirit:hierConnection/@spirit:interfaceRef'))
        {
        my($hierConn_name)                   = $x_name ->to_literal ;
        my($hierConn_comref_name)            = $x_name ->findnodes('../spirit:interface/@spirit:componentRef')->to_literal ;
        my($hierConn_busref_name)            = $x_name ->findnodes('../spirit:interface/@spirit:busRef')->to_literal ;

        foreach  my   $x_name ($spirit_design_file->findnodes("//spirit:design/spirit:componentInstances/spirit:componentInstance/spirit:instanceName"))
           {
           #/**********************************************************************/
           #/*                                                                    */
           #/* Lookup VLNV for each instantiated component                        */
           #/*                                                                    */
           #/**********************************************************************/

           my($instance_name)       = $x_name ->findnodes('./text()')->to_literal ;
          my($vendor_name)         = $x_name  ->findnodes('../spirit:componentRef/@spirit:vendor')->to_literal ;
         my($library_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:library')->to_literal ;
         my($component_name)      = $x_name  ->findnodes('../spirit:componentRef/@spirit:name')->to_literal ;
         my($version_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:version')->to_literal ;

           if( "$instance_name" eq  "$hierConn_comref_name"     )
             {
             my  @filelist_sub = parse_busInterface($vendor_name, $library_name,$component_name,$version_name,$hierConn_busref_name,"1" );
           #/**********************************************************************/
           #/*                                                                    */
           #/* follow bus all the way to it's source                              */
           #/*                                                                    */
           #/**********************************************************************/

             foreach $xxline (@filelist_sub) 
                { 
                $_ = $xxline;
                if(/:::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::/) 
                  { 
                  $k_depth               = $1;
                  $k_log_name            = $2;
                  $k_phy_name            = $3;
                  $k_direction           = $4;
                  $k_type                = $5;
                  $k_vector              = $6;        
                  $k_left                = $7;        
                  $k_right               = $8;
                  push  @wire_decs,":::${hierConn_name}_${k_log_name}:::${hierConn_name}_${k_log_name}:::${k_direction}:::wire:::${k_vector}:::${k_left}:::${k_right}:::${hierConn_comref_name}:::${k_depth}:::${k_phy_name}:::${hierConn_busref_name}:::${k_log_name}:::";
                  }
                }
             }
           }
        }





     #/**************************************************************************/
     #/*                                                                        */
     #/* Read each  interconnection and enter sub signals into wire_decs        */
     #/*                                                                        */
     #/**************************************************************************/




     foreach  my   $x_name ($spirit_design_file->findnodes('//spirit:interconnections/spirit:interconnection/spirit:activeInterface/@spirit:componentRef'))
        {
        my($hierConn_comref_name)            = $x_name ->to_literal;
        my($hierConn_busref_name)            = $x_name ->findnodes('../@spirit:busRef')->to_literal ;
        my($hierConn_name)                   = $x_name ->findnodes('../../spirit:name/text()')->to_literal ;

        foreach  my   $x_name ($spirit_design_file->findnodes("//spirit:design/spirit:componentInstances/spirit:componentInstance/spirit:instanceName"))
           {
           #/**********************************************************************/
           #/*                                                                    */
           #/* Lookup VLNV for each instantiated component                        */
           #/*                                                                    */
           #/**********************************************************************/

           my($instance_name)       = $x_name ->findnodes('./text()')->to_literal ;
           my($vendor_name)         = $x_name  ->findnodes('../spirit:componentRef/@spirit:vendor')->to_literal ;
           my($library_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:library')->to_literal ;
           my($component_name)      = $x_name  ->findnodes('../spirit:componentRef/@spirit:name')->to_literal ;
           my($version_name)        = $x_name  ->findnodes('../spirit:componentRef/@spirit:version')->to_literal ;



           if( "$instance_name" eq  "$hierConn_comref_name"     )
             {



           #/**********************************************************************/
           #/*                                                                    */
           #/* follow bus all the way to it's source                              */
           #/*                                                                    */
           #/**********************************************************************/


             my  @filelist_sub = parse_busInterface($vendor_name, $library_name,$component_name,$version_name,$hierConn_busref_name,"1" );
             foreach $xxline (@filelist_sub) 
                { 


                $_ = $xxline;
                if(/:::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::/) 
                  { 
                  $k_depth               = $1;
                  $k_log_name            = $2;
                  $k_phy_name            = $3;
                  $k_direction           = $4;
                  $k_type                = $5;
                  $k_vector              = $6;        
                  $k_left                = $7;        
                  $k_right               = $8;
     
                  
                  push  @wire_decs,":::${hierConn_name}_${k_log_name}:::${hierConn_name}_${k_log_name}:::node:::wire:::${k_vector}:::${k_left}:::${k_right}:::${hierConn_comref_name}:::${k_depth}:::${k_phy_name}:::${hierConn_busref_name}:::${k_log_name}:::";
                  }
                }
             }
           }
        }



     #/*******************************************************************************/
     #/*                                                                             */
     #/* Read each  interconnection and enter modified signals into wire_decs        */
     #/*                                                                             */
     #/*******************************************************************************/





        foreach  my  $k_name ($spirit_design_file->findnodes('//spirit:interconnections/spirit:interconnection/spirit:activeInterface/spirit:portMaps/spirit:portMap/spirit:logicalPort/spirit:name'))
           {
           my($lp_name)                = $k_name ->to_literal;
           my($lp_pname)               = $k_name ->findnodes('../../spirit:physicalPort/spirit:name/text()')->to_literal ;
           my($lp_left)                = $k_name ->findnodes('../../spirit:physicalPort/spirit:wire/spirit:vector/spirit:left/text()')->to_literal ;
           my($lp_right)               = $k_name ->findnodes('../../spirit:physicalPort/spirit:wire/spirit:vector/spirit:right/text()')->to_literal ;
           my($lp_componentref_name)   = $k_name ->findnodes('../../../../@spirit:componentRef')->to_literal ;
           my($lp_busref_name)         = $k_name ->findnodes('../../../../@spirit:busRef')->to_literal ;
           my($lp_interconnect_name)   = $k_name ->findnodes('../../../../../spirit:name/text()')->to_literal ;


           if ( $lp_pname eq '' ) { $lp_pname ="${lp_interconnect_name}_${lp_name}";}
           if ( $lp_left  eq '' ) { $lp_left ="none";}
           if ( $lp_right eq '' ) { $lp_right ="none";}



          if ( $lp_left  eq 'none' ) 
          { 
           push  @wire_decs,":::${lp_interconnect_name}_${lp_name}:::${lp_pname}:::node:::wire:::scaler:::none:::none:::${lp_componentref_name}:::0:::${lp_interconnect_name}_${lp_name}:::${lp_busref_name}:::${lp_pname}:::";
          }
          else
          { 
           push  @wire_decs,":::${lp_interconnect_name}_${lp_name}:::${lp_pname}:::node:::wire:::vector:::${lp_left}:::${lp_right}:::${lp_componentref_name}:::0:::${lp_interconnect_name}_${lp_name}:::${lp_busref_name}:::${lp_pname}:::";
          }
           }








     #/**********************************************************************/
     #/*                                                                    */
     #/* Read all adHocConnections and load instance connect info into array*/
     #/*                                                                    */
     #/**********************************************************************/


     foreach  my   $i_xame ($spirit_design_file->findnodes('//spirit:adHocConnections/spirit:adHocConnection/spirit:internalPortReference/@spirit:componentRef'))
        {
        my($comp_name)    = $i_xame ->to_literal;
        my($int_value)    = $i_xame ->findnodes('../../spirit:name/text()')->to_literal ;
        my($tied_value)   = $i_xame ->findnodes('../../@spirit:tiedValue')->to_literal ;
        my($int_name)     = $i_xame ->findnodes('../@spirit:portRef')->to_literal ;
        my($vec_name)     = $i_xame ->findnodes('../../spirit:externalPortReference/@spirit:portRef')->to_literal ;
        my($vec_left)     = $i_xame ->findnodes('../../spirit:externalPortReference/@spirit:left')->to_literal ;
        my($vec_right)    = $i_xame ->findnodes('../../spirit:externalPortReference/@spirit:right')->to_literal ;


# print "XXXXXX  $comp_name  $int_name  ( $int_value  $tied_value  )   $vec_name $vec_left $vec_right  \n";


        unless ($int_value)  
         {$int_value = "_DUMMY_";
         }


        if($tied_value )
          { 
          push @inst_conns , ":::${comp_name}:::adhoc:::${int_name}:::${tied_value}:::scaler:::none:::none:::";         
          }
        elsif($vec_left ne "")
          {
          push @inst_conns , ":::${comp_name}:::adhoc:::${int_name}:::${int_value}:::vector:::${vec_left}:::${vec_right}:::";
          push @wire_decs  , ":::${vec_name}:::${int_value}:::node:::wire:::vector:::${vec_left}:::${$vec_right}:::none:::0:::${int_value}:::XXX:::${vec_name}:::";
          }
        else
          {
          push @inst_conns , ":::${comp_name}:::adhoc:::${int_name}:::${int_value}:::scaler:::none:::none:::";         
          push @wire_decs  , ":::${vec_name}:::${int_value}:::node:::wire:::scaler:::none:::none:::none:::0:::${int_value}:::XXX:::${vec_name}:::";
          }           


        }












           






     #/**********************************************************************/
     #/*                                                                    */
     #/* extract bus instance connections from wire_decs                    */
     #/*                                                                    */
     #/**********************************************************************/

     #print "+-+";      

     

     my @inst_names  = (); 
     my @inst_Inames  = (); 
     my %inst_ports  = ();
     my %inst_sigs   = ();
     my %inst_vector = ();
     my %inst_left   = ();
     my %inst_right  = ();


     foreach $line (@wire_decs)  
        { 
        $_ = $line;


        if(/:::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::/) 
          { 
          my $t_index               = $1;
          my $t_node_name           = $2;
          my $t_direction           = $3;
          my $t_type                = $4;
          my $t_vector              = $5;        
          my $t_left                = $6;        
          my $t_right               = $7;
          my $t_instance            = $8;
          my $t_depth               = $9;
          my $t_phy_name            = $10;
          my $t_busref_name         = $11;
          my $t_abslog_name         = $12;

        if( 1)
          {

         push ( @inst_names, "${t_instance}_${t_busref_name}_${t_index}");

         $inst_Inames{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_instance}";

         if(  $inst_sigs{"${t_instance}_${t_busref_name}_${t_index}"})
            {
            if(  $inst_sigs{"${t_instance}_${t_busref_name}_${t_index}"} eq ${t_index})
              {
              $inst_sigs{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_node_name}";
              }
            } 
         else
            {
            $inst_sigs{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_node_name}";
            }

         if   ($t_depth >= 2 )      { $inst_ports{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_busref_name}_${t_abslog_name}" ;}
         elsif($t_depth == 1 )      { $inst_ports{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_phy_name}";}

         if(  $inst_vector{"${t_instance}_${t_busref_name}_${t_index}"})
            {
            if(  $inst_vector{"${t_instance}_${t_busref_name}_${t_index}"} eq "scaler")
              {$inst_vector{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_vector}";}
            } 
         else
            {$inst_vector{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_vector}";}

         unless(  $inst_left{"${t_instance}_${t_busref_name}_${t_index}"} eq '')
            {
            if(  $inst_left{"${t_instance}_${t_busref_name}_${t_index}"} eq "none")
              {
              $inst_left{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_left}";
              }
            elsif(  $inst_left{"${t_instance}_${t_busref_name}_${t_index}"} < ${t_left})
              {
              $inst_left{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_left}";
              }
            } 
          else
            {
            $inst_left{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_left}";
            }

          unless(  $inst_right{"${t_instance}_${t_busref_name}_${t_index}"} eq '')
            {
            if(  $inst_right{"${t_instance}_${t_busref_name}_${t_index}"} eq "none")
              {
              $inst_right{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_right}";
              }
            elsif(  $inst_right{"${t_instance}_${t_busref_name}_${t_index}"} < ${t_right})
              {
              $inst_right{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_right}";
              }
            } 
          else {$inst_right{"${t_instance}_${t_busref_name}_${t_index}"}  = "${t_right}";}

        }
      }
     }
     @inst_names = sys::lib::trim_sort(@inst_names); 
     foreach $i_name (@inst_names)  
         {
        unless($inst_Inames{$i_name} eq "none")
         {
         if($inst_vector{$i_name} eq "vector"  )
           {
          push @inst_conns ,":::$inst_Inames{$i_name}:::adhoc:::$inst_ports{$i_name}:::$inst_sigs{$i_name}:::vector:::$inst_left{$i_name}:::$inst_right{$i_name}:::";
          }
        else
          {
          push @inst_conns ,":::$inst_Inames{$i_name}:::adhoc:::$inst_ports{$i_name}:::$inst_sigs{$i_name}:::scaler:::none:::none:::";         

           }
         }
         }
     }









#/*********************************************************************************************/
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/*********************************************************************************************/




sub process_design_file
   {
   my @params     = @_;
   my $spirit_design_file      = pop(@params);





#print "\n";
foreach my $new_comp ($spirit_design_file->findnodes("//spirit:design/spirit:vendor")) 
   {
   my($new_vendor)          = $new_comp->findnodes('./text()')->to_literal ;
   my($new_library)         = $new_comp->findnodes('../spirit:library/text()')->to_literal ;
   my($new_name)            = $new_comp->findnodes('../spirit:name/text()')->to_literal ;
   my($new_version)         = $new_comp->findnodes('../spirit:version/text()')->to_literal ;
#   print "XXXXXX-  $new_vendor $new_library $new_name $new_version  DESIGN \n";
   }





     #/**********************************************************************/
     #/*                                                                    */
     #/* Instantiate each component with parameters and port connections    */
     #/*                                                                    */
     #/* If the component doesn't have a instance name then this is skipped */
     #/*                                                                    */
     #/**********************************************************************/
      
     #print "+-+";      
      
     push @instantiations  , "////////////////////////////////////////////////////////////////\n"; 


     @inst_conns = sys::lib::trim_sort(@inst_conns);






     foreach  my   $i_name ($spirit_design_file->findnodes("//spirit:design/spirit:componentInstances/spirit:componentInstance/spirit:instanceName"))
        {
        my($instance_name)       = $i_name ->findnodes('./text()')->to_literal ;
        my($vendor_name)         = $i_name  ->findnodes('../spirit:componentRef/@spirit:vendor')->to_literal ;
        my($library_name)        = $i_name  ->findnodes('../spirit:componentRef/@spirit:library')->to_literal ;
        my($component_name)      = $i_name  ->findnodes('../spirit:componentRef/@spirit:name')->to_literal ;
        my($version_name)        = $i_name  ->findnodes('../spirit:componentRef/@spirit:version')->to_literal ;

        my $module_name = yp::lib::get_module_name($vendor_name,$library_name,$component_name,$version_name) ;







        if($instance_name)
          {
          push @instantiations  , "$module_name\n";         
          $first = 1;

          foreach  my   $i_parameter ($spirit_design_file->findnodes("//spirit:componentInstance[spirit:instanceName/text() = '$instance_name']/spirit:configurableElementValues/spirit:configurableElementValue/\@spirit:referenceId"))
             {
             my($foo_name)       = $i_parameter ->to_literal ;
             my($foo_value)      = $i_parameter ->findnodes('../text()')->to_literal ;




             if($first)
               {
               push @instantiations  , "#( .${foo_name} (${foo_value})";
               $first = 0;         
               }  
             else  {push @instantiations  , ",\n   .${foo_name} (${foo_value})";}  
             }

             if($first == 0)  { push @instantiations  , ")\n";}
             push @instantiations  , "$instance_name \n   (\n ";
             $first = 1;




             foreach $line (@inst_conns) 
                {
                $_ = $line;

                if(/:::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::(\S+):::/) 
                  { 
                  my $z_instance_name           = $1;
                  my $z_busRef_name   = $2;
                  my $z_port_name           = $3;
                  my $z_signal_name           = $4;        
                  my $z_vecscal           = $5;
                  my $z_left           = $6;
                  my $z_right           = $7;

                  if($opt_debug ){print  "YYYYYY--    $line  \n";}

                  if($z_vecscal eq "vector")
                    {
                    if($z_left eq $z_right){$z_signal_name =  "${z_signal_name}[${z_left}]" ;}
                    else    {$z_signal_name =  "${z_signal_name}[${z_left}:${z_right}]" ;}
                    }

                  if ($z_signal_name eq "_DUMMY_")  {$z_signal_name = "      ";}     

                  if($instance_name eq  $z_instance_name ) 
                    {
                    if($first)
                      {
                      push @instantiations  ,          "  .${z_port_name}         (${z_signal_name})";
                      $first =0;
                      }
                    else   {           push @instantiations  , ",\n   .${z_port_name}         (${z_signal_name})";}
                    }
                  }
                }

     #print ".";      
     push @instantiations  , ");\n\n";         
     }
     }
     }









#/*********************************************************************************************/
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/                                                                                            */
#/*********************************************************************************************/




sub parse_component_file
   {
   my @params     = @_;
   my $spirit_component_file      = pop(@params);


#print "\n";
foreach my $new_comp ($spirit_component_file->findnodes("//spirit:component/spirit:vendor")) 
   {
   my($new_vendor)          = $new_comp->findnodes('./text()')->to_literal ;
   my($new_library)         = $new_comp->findnodes('../spirit:library/text()')->to_literal ;
   my($new_name)            = $new_comp->findnodes('../spirit:name/text()')->to_literal ;
   my($new_version)         = $new_comp->findnodes('../spirit:version/text()')->to_literal ;
   if($opt_verbose){print "parse_component_file   $new_vendor $new_library $new_name $new_version  COMPONENT \n";}
   }




     #/**********************************************************************/
     #/*                                                                    */
     #/* parse parameters and values                                        */
     #/*                                                                    */
     #/**********************************************************************/
         
     foreach  my   $i_name ($spirit_component_file->findnodes('//spirit:model/spirit:modelParameters/spirit:modelParameter/spirit:name'))
        {
        my($parameter_name)     = $i_name ->to_literal;
        my($parameter_default)  = $i_name ->findnodes('../spirit:value/text()')->to_literal ;

        unless(defined $parameter_values{$parameter_name}) 
         {
         push ( @parameters,  "$parameter_name");
         $parameter_values{$parameter_name} = ${parameter_default};
#         $parameter_descriptions{$parameter_name} = "Duhkkk";


         foreach my $socgen_cfg ($socgen_file->findnodes("//socgen:componentConfiguration/socgen:doc/socgen:parameters/socgen:parameter/socgen:name[text() = '$parameter_name']")) 
             {
             my($param_description)        = $socgen_cfg->findnodes('../socgen:description/text()')->to_literal ;
             $parameter_descriptions{$parameter_name} = $param_description ;
             }



         };

        }
      






foreach my $new_comp ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:views/spirit:view/spirit:vendorExtensions/spirit:componentRef")) 
   {
    my($new_vendor)        = $new_comp->findnodes('./@spirit:vendor')->to_literal ;
    my($new_library)       = $new_comp->findnodes('./@spirit:library')->to_literal ;
    my($new_name)          = $new_comp->findnodes('./@spirit:name')->to_literal ;
    my($new_version)       = $new_comp->findnodes('./@spirit:version')->to_literal ;
    if(yp::lib::find_ipxact_component($new_vendor,$new_library,$new_name,$new_version))
     {
     parse_component_file($parser->parse_file(yp::lib::find_ipxact_component($new_vendor,$new_library,$new_name,$new_version))    );
     }

   }





     #/**********************************************************************/
     #/*                                                                    */
     #/* Read each  busInterface and save master/slave direction            */
     #/*                                                                    */
     #/**********************************************************************/

     my @mas_slave;

     push @mas_slave  , "master"; 
     push @mas_slave  , "slave"; 

     foreach $seek_type (@mas_slave) 
        { 

         foreach my $bus_iface ($spirit_component_file->findnodes("//spirit:component/spirit:busInterfaces/spirit:busInterface/spirit:${seek_type}")) 
            {
            my($mmm_cname)         = $bus_iface->findnodes('../spirit:name/text()')->to_literal ;
            my($mmm_vendor)        = $bus_iface->findnodes('../spirit:abstractionType/@spirit:vendor')->to_literal ;
            my($mmm_library)       = $bus_iface->findnodes('../spirit:abstractionType/@spirit:library')->to_literal ;
            my($mmm_name)          = $bus_iface->findnodes('../spirit:abstractionType/@spirit:name')->to_literal ;
            my($mmm_version)       = $bus_iface->findnodes('../spirit:abstractionType/@spirit:version')->to_literal ;
   
            foreach my $port_face ($spirit_component_file->findnodes('//spirit:component/spirit:busInterfaces/spirit:busInterface/spirit:portMaps/spirit:portMap/spirit:logicalPort')) 
               {
               my($rrr_log_name)      = $port_face->findnodes('./spirit:name/text()')->to_literal ;
               my($rrr_int_name)      = $port_face->findnodes('../../../spirit:name/text()')->to_literal ;
               my($rrr_phy_name)      = $port_face->findnodes('../spirit:physicalPort/spirit:name/text()')->to_literal ;
               my($rrr_type_name)     = $port_face->findnodes('../spirit:physicalPort/spirit:wireTypeDefs/spirit:wireTypeDef/spirit:typeName/text()')->to_literal ;
               my($rrr_left_value)    = $port_face->findnodes('../spirit:physicalPort/spirit:wire/spirit:vector/spirit:left/text()')->to_literal ;
               my($rrr_right_value)   = $port_face->findnodes('../spirit:physicalPort/spirit:wire/spirit:vector/spirit:right/text()')->to_literal ;
    
               unless ($rrr_type_name)  {$rrr_type_name = "wire";}
    
               if(   $mmm_cname  eq  $rrr_int_name )
                 {
                 my $absDef_filename = yp::lib::get_absDef_db_filename($mmm_vendor,$mmm_library,$mmm_name,$mmm_version);
                 $absDef_db   = new BerkeleyDB::Hash( -Filename => $absDef_filename, -Flags => DB_CREATE ) or die "Cannot open ${absDef_filename}: $!";

                  my $abs_data;
                  $absDef_db->db_get("${seek_type}__${rrr_log_name}", $abs_data );

                 ( $berk_name, $berk_presence,$berk_width,$berk_direction ) = split ':', $abs_data;
                      
                 my        $rrr_direction = $berk_direction;
                 if($rrr_left_value ne "")
                     { 
                     push @wire_decs , ":::${mmm_cname}_${rrr_log_name}:::${rrr_phy_name}:::${rrr_direction}:::${rrr_type_name}:::vector:::${rrr_left_value}:::${$rrr_right_value}:::none:::0:::${rrr_phy_name}:::XXX:::${rrr_log_name}:::"; 
                      }
                  else                
                      { 
                      push @wire_decs , ":::${mmm_cname}_${rrr_log_name}:::${rrr_phy_name}:::${rrr_direction}:::${rrr_type_name}:::scaler:::none:::none:::none:::0:::${rrr_phy_name}:::XXX:::${rrr_log_name}:::";    
                       }               
                    

                  $absDef_db->db_close();              
                 }
               }
        }
     }




     #/**********************************************************************/
     #/*                                                                    */
     #/* Read all ports and store into array                                */
     #/*                                                                    */
     #/**********************************************************************/

     foreach  my   $i_name ($spirit_component_file->findnodes("//spirit:component/spirit:model/spirit:ports/spirit:port/spirit:name"))
        {
        my($port_name)       = $i_name ->findnodes('./text()')->to_literal ;
        my($direction)       = $i_name ->findnodes('../spirit:wire/spirit:direction/text()')->to_literal ;
        my($left)            = $i_name ->findnodes('../spirit:wire/spirit:vector/spirit:left/text()')->to_literal ;
        my($right)           = $i_name ->findnodes('../spirit:wire/spirit:vector/spirit:right/text()')->to_literal ;
        my($type)            = $i_name ->findnodes('../spirit:wireTypeDefs/spirit:wireTypeDef/spirit:typeName/text()')->to_literal ;


        if    ($direction eq "in")  { $direction = "input";}
        elsif ($direction eq "out") { $direction = "output";}


        if($left ne "")  { push @wire_decs , ":::${port_name}:::${port_name}:::${direction}:::${type}:::vector:::${left}:::${right}:::none:::0:::${port_name}:::XXX:::${port_name}:::";  }
        else       { push @wire_decs , ":::${port_name}:::${port_name}:::${direction}:::${type}:::scaler:::none:::none:::none:::0:::${port_name}:::XXX:::${port_name}:::";          }
        }

 


}


1

