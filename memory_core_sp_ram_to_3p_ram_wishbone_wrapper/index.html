<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='wb_3p_spram_wrapper.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: wb_3p_spram_wrapper
    <br/>
    Created: Nov  7, 2008
    <br/>
    Updated: Jan 23, 2009
    <br/>
    SVN Updated: Mar 10, 2009
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Memory core
    
    <br/>
    Language:
    
     VHDL
    
    <br/>
    Development status:
    
     Stable
    
    <br/>
    Additional info:
    
     FPGA proven
    
    <br/>
    WishBone Compliant: Yes
    <br/>
    License: LGPL
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     This is a wrapper for an inferred single port RAM, that converts it into a Three-port RAM with one WISHBONE slave interface for each port.
     <br/>
     Very useful as a drop-in module to create configuration registers for any core.
     <br/>
    </p>
   </div>
   <div id="d_Features">
    <h2>
     
     
     Features
    </h2>
    <p id="p_Features">
     - Generics for data and address widths of internal RAM
     <br/>
     - Included inferred single port ram (but ready to use an instantiated SPRAM component, i.e.: generated by coregen)
     <br/>
     - Wait states are reduced to the very minimum (writes immediately acked)
     <br/>
     - Provides a way to lock access to only one port at a time (by keeping wb_cyc line high in the port of the locking master)
     <br/>
     - Priority switching to avoid deadlocks (when one port is freed, the next port's pending request will be serviced)
     <br/>
    </p>
   </div>
   <div id="d_Status">
    <h2>
     
     
     Status
    </h2>
    <p id="p_Status">
     - 07/11/2008: Project created in OpenCores
    </p>
   </div>
   <div id="d_Interface">
    <h2>
     
     
     Interface
    </h2>
    <p id="p_Interface">
     The interface includes the standard WISHBONE lines: wb_clk_i and wb_rst_i (active high asynchronous reset).
     <br/>
     Apart from these two, there are three independent WISHBONE slave ports, each with the following lines (N goes from 1 to 3):
     <br/>
     - wbN_cyc_i
     <br/>
     - wbN_stb_i
     <br/>
     - wbN_we_i
     <br/>
     - wbN_adr_i
     <br/>
     - wbN_dat_i
     <br/>
     - wbN_dat_o
     <br/>
     - wbN_ack_o
     <br/>
     IMPORTANT: To achieve the best performance, memory writes are implemented with immediate acks. This means that no read is performed during a write, so wb_dat_o MUST be ignored when a write is acked.
     <br/>
     OPERATION:
     <br/>
     Let's define the situation as one in which there are three masters (A,B, and C) connected to this core, trying to do simultaneous operations on the spram, each one connected to one of the WB ports (A -&gt; wb1, B -&gt; wb2, and C -&gt; wb3).
     <br/>
     Of course, if one port is not used, its cyc and stb lines MUST be tied low to prevent the core from deadlocking. Take note also that if one port is not used, the core won't see its performance affected, that is, it will work as if it were a two port wrapper, instead of three ports.
     <br/>
     <br/>
     NORMAL OPERATIONS:
     <br/>
     In case there is no need to make atomic operations, a master connected to a port of this core can work as if there weren't any other masters connected to other ports.
     <br/>
     Plus, the core switches the port priority the moment a master (that was using the memory) drives low its cyc and stb lines.
     <br/>
     That is, for example: master B does an operation (R/W), and it is acked by this core. Then, if master B drives low its cyc and stb lines, and in the next cycle master B and master C rise their cyc and stb lines simultaneously, master C will be the one serviced, not master B again. This way a greedy master won't take up the bus.
     <br/>
     <br/>
     ATOMIC OPERATIONS (port locking):
     <br/>
     Let's suppose that master B wants to make a set of atomic operations consisting of one read, then a pause of 20 cycles, then a write, then another pause of 5 cycles and then another write. This master (B) needs to know that no other master connected to this core (A or C) does any read or write to the memory, while this set of atomic operations is being performed.
     <br/>
     In order to make atomic operations, master B (which is connected to, for example, the 2nd WB port) would need to drive high the wb2_cyc and wb2_stb lines, to perform the first read of the set of atomic operations. After receiving the ack from this core, master B will drive low ONLY the line wb2_stb during the 20 pause cycles master B to prepare the next write it needs to do.
     <br/>
     Then, master B should drive high again the stb line and perform the write (of course rising also the "we_i" line and putting the right data on "dat_i" and "adr_i" lines), remember that the cyc line was already up, to lock the memory on to this port.
     <br/>
     After receiving the ack for this write, the master B of this example needs another 5 cycles of processing in which it won't make any other operations on the RAM, so after the second ack (the one corresponding to the second WB operation, the write) it will drive low ONLY the wb2_stb line, keeping cyc high, that way the memory bus is locked on to this port, and it won't service requests, again, from other ports.
     <br/>
     After the five cycles, master B makes its last operation of the example, another write, by driving high the stb line (and with the rigth we_i, dat_i and adr_i lines, obviously) and waiting to be acked by this core, meaning that the memory was written. After receiving this third, and last, ack master B will drive low its wb2_cyc and wb2_stb lines, because it has ended the atomic set of operations, so that master A and C can keep on using the memory.
     <br/>
     I short: Keeping the wbN_cyc line high with the wbN_stb line low (after being acked once) will signal to this core that the memory must be kept locked on to master N and no other request from other ports will be serviced until the cyc line is lowered again.
     <br/>
     A WISHBONE slave port N may be considered locked onto its master X when:
     <br/>
     1) this slave port N acks one time
     <br/>
     2) the wbN_cyc line is not driven low by master X.
     <br/>
     From this point on, the acked master may make any operations on this slave port, knowing for sure that no other master will be able to access the memory until the cyc line is driven low again. (the "slave acks one time" requirement is because up until that moment, the master can not be sure that there is another master already locking this slave)
     <br/>
     In simple terms, any group of atomic operations must be preceded by a read, and the cyc line must not be driven low until the end.
    </p>
   </div>
   <div id="d_">
    <h2>
     
     
    </h2>
    <p id="p_">
     
      <img src="//www.visengi.com/imgs/bannerOC"/>
     
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
