------------------------------------------------------------------------------
-- Author        : Timo Alho
-- e-mail        : timo.a.alho@tut.fi
-- Date          : 11.08.2004 13:28:10
-- File          : DCT1D_DA.vhd
-- Design        : VHDL Entity for dct.DCT1D_DA.symbol
-- Generated by Mentor Graphics' HDL Designer 2003.1 (Build 399)
------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY dct;
USE dct.DCT_pkg.all;
LIBRARY common_da;

ENTITY DCT1D_DA IS
   PORT( 
      clk            : IN     std_logic;
      dct_input_data : IN     std_logic_vector (8*DCT_dataw_co-1 DOWNTO 0);
      last_bit       : IN     std_logic;
      rst_n          : IN     std_logic;
      start          : IN     std_logic;
      dct1d_out      : OUT    std_logic_vector (8*DCT_dataw_co-1 DOWNTO 0)
   );

-- Declarations

END DCT1D_DA ;

------------------------------------------------------------------------------
-- Author        : Timo Alho
-- e-mail        : timo.a.alho@tut.fi
-- Date          : 11.08.2004 13:28:11
-- File          : DCT1D_DA.vhd
-- Design        : VHDL Architecture for dct.DCT1D_DA.symbol
-- Generated by Mentor Graphics' HDL Designer 2003.1 (Build 399)
------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY dct;
USE dct.DCT_pkg.all;
LIBRARY common_da;


ARCHITECTURE struct OF DCT1D_DA IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL Coeff_sub  : std_logic_vector(4*DCT_coeffw_co-1 DOWNTO 0);
   SIGNAL Coeff_sum  : std_logic_vector(4*DCT_coeffw_co-1 DOWNTO 0);
   SIGNAL Vec        : std_logic_vector(7 DOWNTO 0);
   SIGNAL Vecsub     : std_logic_vector(3 DOWNTO 0);
   SIGNAL Vecsum     : std_logic_vector(3 DOWNTO 0);
   SIGNAL start_calc : std_logic;


   -- ModuleWare signal declarations(v1.0) for instance 'I7' of 'adff'
   SIGNAL mw_I7creg : std_logic := '0';

   -- Component Declarations
   COMPONENT Parallel2Serial
   GENERIC (
      dataw_g : integer := 18
   );
   PORT (
      clk   : IN     std_logic ;
      d_in  : IN     std_logic_vector (dataw_g-1 DOWNTO 0); --parallel input data
      load  : IN     std_logic ;                            --'1' => d_in is loaded in
      rst_n : IN     std_logic ;
      d_out : OUT    std_logic                              --serial output data
   );
   END COMPONENT;
   COMPONENT Serial_adder
   PORT (
      clk     : IN     std_logic ;
      in0     : IN     std_logic ; --serial data input 0
      in1     : IN     std_logic ; --serial data input 1
      rst_n   : IN     std_logic ;
      start   : IN     std_logic ; --start (ignores carrybit)
      sum_out : OUT    std_logic   --serial data outuput
   );
   END COMPONENT;
   COMPONENT Serial_multiplier
   GENERIC (
      coeffw_g    : integer := 14;
      i_dataw_g   : integer := 18;
      round_val_g : integer := 64
   );
   PORT (
      clk        : IN     std_logic ;
      --last_value must be '1', when last bit (MSB) of multiplier is
      --processed
      last_value : IN     std_logic ;
      --multiplicand input
      mul_in     : IN     std_logic_vector (coeffw_g-1 DOWNTO 0);
      rst_n      : IN     std_logic ;
      --start = '1' clears the partial result register
      start      : IN     std_logic ;
      --result output
      mul_out    : OUT    std_logic_vector (i_dataw_g-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT Serial_subtractor
   PORT (
      clk     : IN     std_logic ;
      in0     : IN     std_logic ; --serial data in 0
      in1     : IN     std_logic ; --serial data in 1
      rst_n   : IN     std_logic ;
      start   : IN     std_logic ; --start (ignores borrowbit)
      sub_out : OUT    std_logic   --serial data out
   );
   END COMPONENT;
   COMPONENT Rom_dct_sub
   GENERIC (
      coeffw_g : integer := 14
   );
   PORT (
      addr_in  : IN     std_logic_vector (3 DOWNTO 0);
      clk      : IN     std_logic ;
      data_out : OUT    std_logic_vector (4*coeffw_g-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT Rom_dct_sum
   GENERIC (
      coeffw_g : integer := 14
   );
   PORT (
      addr_in  : IN     std_logic_vector (3 DOWNTO 0);
      clk      : IN     std_logic ;
      data_out : OUT    std_logic_vector (4*coeffw_g-1 DOWNTO 0)
   );
   END COMPONENT;


BEGIN

   -- ModuleWare code(v1.0) for instance 'I7' of 'adff'
   start_calc <= mw_I7creg;
   -- exemplar async_set_reset_local of I7seq "rst_n"
   I7seq: PROCESS (clk, rst_n)
   BEGIN
      IF (rst_n = '0' OR rst_n = 'L') THEN
         mw_I7creg <= '0';
      ELSIF (clk'EVENT AND clk='1') THEN
         mw_I7creg <= start;
      END IF;
   END PROCESS I7seq;

   -- Instance port mappings.
   rom_sub : Rom_dct_sub
      GENERIC MAP (
         coeffw_g => DCT_coeffw_co
      )
      PORT MAP (
         addr_in  => Vecsub,
         clk      => clk,
         data_out => Coeff_sub
      );
   rom_sum : Rom_dct_sum
      GENERIC MAP (
         coeffw_g => DCT_coeffw_co
      )
      PORT MAP (
         addr_in  => Vecsum,
         clk      => clk,
         data_out => Coeff_sum
      );

   g0: FOR i IN 0 TO 7 GENERATE
      input_p2s : Parallel2Serial
         GENERIC MAP (
            dataw_g => DCT_dataw_co
         )
         PORT MAP (
            clk=>clk,
            rst_n=>rst_n,
            load=>start,
            d_in=> dct_input_data((i+1)*DCT_dataw_co-1 DOWNTO i*DCT_dataw_co),
            d_out=>Vec(i)
         );
   END GENERATE g0;

   g1: FOR i IN 0 TO 3 GENERATE
      sumterm_adder : Serial_adder
         PORT MAP (
            clk=>clk,
            rst_n=>rst_n,
            start=>start_calc,
            in1=> Vec(7-i),
            in0=>Vec(i),
            sum_out=>Vecsum(i)
         );
   END GENERATE g1;

   g2: FOR i IN 0 TO 3 GENERATE
      subterm_subtractor : Serial_subtractor
         PORT MAP (
            clk=>clk,
            rst_n=>rst_n,
            start=>start_calc,
            in1=> Vec(7-i),
            in0=>Vec(i),
            sub_out=>Vecsub(i)
         );
   END GENERATE g2;

   g3: FOR i IN 0 TO 3 GENERATE
      sumterm_mul : Serial_multiplier
         GENERIC MAP (
            coeffw_g    => DCT_coeffw_co,
            i_dataw_g   => DCT_dataw_co,
            round_val_g => DCT_rounding_value_co
         )
         PORT MAP (
            clk=>clk,
            rst_n=>rst_n,
            last_value=>last_bit,
            start=>start_calc,
            mul_out=>dct1d_out((i*2+1)*DCT_dataw_co-1 DOWNTO (i*2)*DCT_dataw_co),
            mul_in=>Coeff_sum((4-i)*DCT_coeffw_co-1 DOWNTO (3-i)*DCT_coeffw_co)
         );
   END GENERATE g3;

   g4: FOR i IN 0 TO 3 GENERATE
      subterm_mul : Serial_multiplier
         GENERIC MAP (
            coeffw_g    => DCT_coeffw_co,
            i_dataw_g   => DCT_dataw_co,
            round_val_g => DCT_rounding_value_co
         )
         PORT MAP (
            clk=>clk,
            rst_n=>rst_n,
            last_value=>last_bit,
            start=>start_calc,
            mul_out=>dct1d_out((i*2+1+1)*DCT_dataw_co-1 DOWNTO (i*2+1)*DCT_dataw_co),
            mul_in=>Coeff_sub((4-i)*DCT_coeffw_co-1 DOWNTO (3-i)*DCT_coeffw_co)
         );
   END GENERATE g4;

END struct;
