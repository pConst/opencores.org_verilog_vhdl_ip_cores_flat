*******************************************************************************************************************************************
NOTE: The information bellow is not current. It is here only for historical reasons.
*******************************************************************************************************************************************

if( ir[15:12] == 4'b0000 && ir[8] == 1'b0 && ir[11:9] != 3'b100 && ir[11:9] != 3'b110 &&
    ir[15:0] != 16'b0000_000_0_00_111100 && ir[15:0] != 16'b0000_000_0_01_111100 &&
    ir[15:0] != 16'b0000_001_0_00_111100 && ir[15:0] != 16'b0000_001_0_01_111100 &&
    ir[15:0] != 16'b0000_101_0_00_111100 && ir[15:0] != 16'b0000_101_0_01_111100
)
    ANDI,EORI,ORI,ADDI,SUBI
+++
    if( ir[7:6] == 2'b00 ) load ir1[7:0] to operand1[7:0]
    else if( ir[7:6] == 2'b01 ) load ir1[15:0] to operand1[15:0]
    else if( ir[7:6] == 2'b10 ) load { ir1, ir2 } to operand1[31:0]
    
    move operand1 to operand2
    
    operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    load (ea) from ir[5:0] to operand1: data alter
                                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    
    perform ALU operation:
        if( ir[11:9] == 3'b000 ) OR
        else if( ir[11:9] == 3'b001 ) AND
        else if( ir[11:9] == 3'b010 ) SUB
        else if( ir[11:9] == 3'b011 ) ADD
        else if( ir[11:9] == 3'b101 ) EOR
    
    update CCR:
        ANDI,EORI,ORI:    X not affected; C cleared; V cleared; Z set if zero else clear; N set if MSB set else cleared
        ADDI,SUBI: same as ADD: X=C set if carry[borrow] generated else cleared; V set if overflow else cleared; Z set if result zero else cleared;
            N set if result negative else cleared
        
    save result to (ea) from ir[5:0]
    
    update PC

if( ir[15:0] == 16'b0000_000_0_00_111100 || ir[15:0] == 16'b0000_000_0_01_111100 ||
    ir[15:0] == 16'b0000_001_0_00_111100 || ir[15:0] == 16'b0000_001_0_01_111100 ||
    ir[15:0] == 16'b0000_101_0_00_111100 || ir[15:0] == 16'b0000_101_0_01_111100
)
    ORI to CCR,ORI to SR,ANDI to CCR,ANDI to SR,EORI to CCR,EORI to SR
+++
    if( ir[7:6] == 2'b00 ) load ir1[7:0] to operand1[7:0]
    else if( ir[7:6] == 2'b01 ) load ir1[15:0] to operand1[15:0]
    else if( ir[7:6] == 2'b10 ) load { ir1, ir2 } to operand1[31:0]
    
    move operand1 to operand2
    
    operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    move SR to operand1
    
    perform ALU operation:
        if( ir[11:9] == 3'b000 ) OR
        else if( ir[11:9] == 3'b001 ) AND
        else if( ir[11:9] == 3'b101 ) EOR
    
    move result to operand1
    
    save operand1 to CCR/SR
    
    update CCR:
        result
    
    update PC
    
if( ir[15:12] == 4'b0000 && ir[8] == 1'b0 && ir[11:9] = 3'b110 )
    CMPI
+++
    if( ir[7:6] == 2'b00 ) load ir1[7:0] to operand2[7:0]
    else if( ir[7:6] == 2'b01 ) load ir1[15:0] to operand2[15:0]
    else if( ir[7:6] == 2'b10 ) load { ir1, ir2 } to operand2[31:0]
    
    operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    load (ea) from ir[5:0] to operand1: data alter
                                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    
    perform ALU operation:
        if( ir[11:9] == 3'b110 ) CMP=SUB
    
    update CCR:
        CMPI: same as CMP: X not affected; C set if borrow else cleared; V set if overflow else cleared; Z set if zero else cleared;
            N set if negative else cleared
    
    update PC

if( ir[15:12] == 4'b0000 && ir[11:8] == 4'b1000 && ir[7:6] != 2'b00 )
    BCHG,BCLR,BSET immediate
+++
    load ir1[7:0] to operand1[7:0]
    
    move operand1 to operand2
    
    load (ea) form ir[5:0] to operand1: data alter
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    
    operation size:
    if( ir[5:3] == 3'b000 ) long
    else if( ir[5:3] != 3'b000 ) byte
    
    perform bit operation:
    test( <number> of Destination ) -> Z; test( <number> of Destination )[0][1] -> <bit number> of Destination
    if( ir[7:6] == 2'b01 ) BCHG
    else if( ir[7:6] == 2'b10 ) BCLR
    else if( ir[7:6] == 2'b11 ) BSET
    
    update CCR: X,N,V,C not affected; Z set if bit tested is zero else cleared
    
    save result to (ea) form ir[5:0]
    
    update PC

if( ir[15:12] == 4'b0000 && ir[11:8] == 4'b1000 && ir[7:6] == 2'b00 )
    BTST immediate
+++
    load ir1[7:0] to operand1[7:0]
    
    move operand1 to operand2
    
    load (ea) form ir[5:0] to operand1: data address
        data address:            Dn 000,                    (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,                (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    operation size:
    if( ir[5:3] == 3'b000 ) long
    else if( ir[5:3] != 3'b000 ) byte
    
    perform bit operation:
    test( <number> of Destination ) -> Z
    if( ir[7:6] == 2'b00 ) BTST
    
    update CCR: X,N,V,C not affected; Z set if bit tested is zero else cleared
    
    update PC

if( ir[15:12] == 4'b0000 && ir[8] == 1'b1 && ir[5:3] != 3'b001 && ir[8:6] != 3'b100 )
    BCHG,BCLR,BSET register
+++
    load (ea) from ir[11:9] to operand1[7:0]: Dn
    
    move operand1 to operand2
    
    load (ea) form ir[5:0] to operand1: data alter
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
        
    operation size:
    if( ir[5:3] == 3'b000 ) long
    else if( ir[5:3] != 3'b000 ) byte
    
    perform bit operation:
    test( <number> of Destination ) -> Z; test( <number> of Destination )[0][1] -> <bit number> of Destination
    if( ir[7:6] == 2'b01 ) BCHG
    else if( ir[7:6] == 2'b10 ) BCLR
    else if( ir[7:6] == 2'b11 ) BSET
    
    update CCR: X,N,V,C not affected; Z set if bit tested is zero else cleared
    
    save result to (ea) form ir[5:0]
    
    update PC

if( ir[15:12] == 4'b0000 && ir[8] == 1'b1 && ir[5:3] != 3'b001 && ir[8:6] == 3'b100 )
    BTST register
+++
    load (ea) from ir[11:9] to operand1[7:0]: Dn
    
    move operand1 to operand2
    
    load (ea) form ir[5:0] to operand1: data address
        data address:            Dn 000,                    (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,                (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    operation size:
    if( ir[5:3] == 3'b000 ) long
    else if( ir[5:3] != 3'b000 ) byte
    
    perform bit operation:
    test( <number> of Destination ) -> Z
    if( ir[7:6] == 2'b00 ) BTST
    
    update CCR: X,N,V,C not affected; Z set if bit tested is zero else cleared
    
    update PC
    
if( ir[15:12] == 4'b0000 && ir[8] == 1'b1 && ir[5:3] == 3'b001 && ( ir[7:6] == 2'b00 || ir[7:6] == 2'b01 ) )
    MOVEP memory to register
+++    
    operation size:
    if( ir[7:6] == 2'b00 ) word
    if( ir[7:6] == 2'b01 ) long
    
    load ea from ir[2:0] to address register: (d16, An)
        
    do
        load from (address) to operand1 register, long
        move two alternate bytes to result register
        increment ea by 4
    repeat for long
    
    save result to (ea) from ir[11:9]: Dn, word ( ir[7:6] == 2'b00 ), long ( ir[7:6] == 2'b01 )
    
    update CCR: no change
    update PC
    
if( ir[15:12] == 4'b0000 && ir[8] == 1'b1 && ir[5:3] == 3'b001 && ( ir[7:6] == 2'b10 || ir[7:6] == 2'b11 ) )
    MOVEP register to memory
+++    
    operation size:
    if( ir[7:6] == 2'b10 ) word
    if( ir[7:6] == 2'b11 ) long
    
    load (ea) from ir[11:9] to operand1: Dn, long
    
    load ea from ir[2:0] to address register: (d16, An)
        
    do
        move two alternate bytes to result register
        save result register to (addreess), long, only selected bytes
        increment ea by 4
    repeat for long
        
    update CCR: no change
    update PC
    
if( ir[15:14] == 2'b00 && ir[13:12] != 2'b00 && ir[8:6] != 3'b001)
    MOVE
+++    
    size of operation: ir[13:12]: 01,11,10 byte,word,long
    
    load (ea) from ir[5:0] to operand1: all modes.
        all modes:                Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    copy operand1 to result register
    
    save result to (ea) from ir[11:6]: data alter.
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    CC: X not affected; C cleared; V cleared; Z set if zero else cleared; N set if negative else cleared
        
    update PC

if( ir[15:14] == 2'b00 && (ir[13:12] == 2'b11 || ir[13:12] == 2'b10) && ir[8:6] == 3'b001)
    MOVEA
+++    
    size of operation: ir[13:12]: 11,10 word,long
    
    load (ea) from ir[5:0] to operand1: all modes.
        all modes:                Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    copy operand1 to result register
    
    save result to (ea) from ir[11:6]: An
    
    CC: not affected
        
    update PC

if( ir[15:12] == 4'b1100 && (ir[8:4] == 5'b10100 || 5'b11000) )
    EXG
+++
    load (ea) from ir[5:0] to operand1: Dn, An
    
    perform ALU operation: move operand1 to result register
    
    load (ea) from ir[11:9] with mode in ir[7:3] to operand1: Dn (5'b01000 or 5'b10001), An (5'b01001)
    
    save result to (ea) from ir[11:9] with mode in ir[7:3]: Dn (5'b01000 or 5'b10001), An (5'b01001), 
    
    perform ALU operation: move operand1 to result register
    
    save result to (ea) from ir[5:0]: Dn, An

    CC: not affected
    
    update PC
    
if( ir[15:12] == 4'b1011 && (ir[8:6] == 3'b100 || 3'b101 || 3'b110) && ir[5:3] == 3'b001 )
    CMPM
+++
    load (ea) from ir[2:0] to operand1: postincrement (An)+
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: postincrement (An)+
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    perform ALU operation: CMPM == SUB
    
    CC: X not affected; C set if borrow else cleared; V set if overflow else cleared; Z set if zero else cleared; N set if negative else cleared
    Ax dest, Ay source: postincrement: +(An)

    update PC

if( ir[15:12] == 4'b1011 && (ir[8:6] == 3'b100 || 3'b101 || 3'b110) && ir[5:3] != 3'b001 )
    EOR
+++
    load (ea) from ir[11:9] to operand1: Dn
    
    move operand1 to operand2
    
    load (ea) from ir[5:0] to operand1: data alter
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    perform ALU operation: EOR
    
    CC: X not affected; C cleared; V cleared; Z set if zero else clear; N set if MSB set else cleared

    save result to (ea) from ir[5:0]: data alter
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    update PC
    
if( (ir[15:12] == 4'b1101 || 4'b1001 || 4'b1100 || 4'b1000) &&
    (ir[8:4] == 5'b10001 || 5'b10010 || 5'b10011 || 5'b10101 || 5'b10110 || 5'b10111 || 5'b11001 || 5'b11010 || 5'b11011) )
    
    ADD to mem,SUB to mem,AND to mem,OR to mem
+++
    load (ea) from ir[11:9] to operand1: Dn
    
    move operand1 to operand2
    
    load (ea) indexed by ir[5:0] to operand1: memory alter
        memory alter:                                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    perform ALU operation:
    if( ir[15:12] == 4'b1101 ) ADD
    else if( ir[15:12] == 4'b1001 ) SUB
    else if( ir[15:12] == 4'b1100 ) AND
    else if( ir[15:12] == 4'b1000 ) OR
    
    if( ADD,SUB )
        CC: X=C set if carry[borrow] generated else cleared; V set if overflow else cleared; Z set if result zero else cleared;
            N set if result negative else cleared
    else if( AND,OR )
        CC: X not affected; C cleared; V cleared; Z set if zero else clear; N set if MSB set else cleared
    
    save result to (ea) from ir[5:0]: memory alter
        memory alter:                                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    
    update PC
    
if( (ir[15:12] == 4'b1101 || 4'b1001 || 4'b1100 || 4'b1000) && (ir[8:6] == 3'b000 || 3'b001 || 3'b010) )
    ADD to Dn,SUB to Dn,AND to Dn,OR to Dn
+++
    load (ea) from ir[5:0] to operand1: all modes
        all modes:                 Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: Dn
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    perform ALU operation:
    if( ir[15:12] == 4'b1101 ) ADD
    else if( ir[15:12] == 4'b1001 ) SUB
    else if( ir[15:12] == 4'b1100 ) AND
    else if( ir[15:12] == 4'b1000 ) OR
    
    if( ADD,SUB )
        CC: X=C set if carry[borrow] generated else cleared; V set if overflow else cleared; Z set if result zero else cleared;
            N set if result negative else cleared
    else if( AND,OR )
        CC: X not affected; C cleared; V cleared; Z set if zero else clear; N set if MSB set else cleared

    save result to (ea) from ir[11:9]: Dn
    
    update PC

if( (ir[15:12] == 4'b1011) && (ir[8:6] == 3'b000 || 3'b001 || 3'b010) )
    CMP
+++
    load (ea) from ir[5:0] to operand1: all modes
        all modes:                 Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: Dn
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    perform ALU operation:
    if( ir[15:12] == 4'b1011 ) CMP=SUB
    
    CC: X not affected; C set if borrow else cleared; V set if overflow else cleared; Z set if zero else cleared; N set if negative else cleared
    
    update PC

if( (ir[15:12] == 4'b1100 || 4'b1000) && ir[7:6] == 2'b11 )
    MULS,MULU,DIVS,DIVU
+++
    load (ea) from ir[5:0] to operand1: data
            data:        Dn 000,                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                        (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: Dn
    
    perform ALU operation:
    if( ir[15:12] == 4'b1100 && ir[8] == 1'b0 ) MULU
    else if( ir[15:12] == 4'b1100 && ir[8] == 1'b1 ) MULS
    else if( ir[15:12] == 4'b1000 && ir[8] == 1'b0 ) DIVU
    else if( ir[15:12] == 4'b1000 && ir[8] == 1'b1 ) DIVS
    
    if( MULU/MULS )
        CC: X not affected; C cleared; V cleared; Z set if zero else cleared; N set if negative else cleared
    else if( DIVU/DIVS )
        CC: X not affected; C cleared; V set if overflow else if trap undefined else cleared;
            Z set if quotient zero else if trap or overflow undefined else cleared;
            N set if quotient negative else if trap or overflow undefined else cleared; 
    
    save result to (ea) from ir[11:9]: Dn
    
    update PC

if( (ir[15:12] == 4'b1101 || 4'b1001) && (ir[8:6] == 3'b011 || 3'b111) )
    ADDA,SUBA
+++    
    load (ea) from ir[5:0] to operand1: all modes
        all modes:                Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: An
    
    ALU operation size, source is sign-extended:
    if( ir[8] == 1'b0 ) word
    else if( ir[8] == 1'b1 ) long
    
    perform ALU operation:
    if( ir[14:12] == 3'b101 ) ADD
    else if( ir[14:12] == 3'b001 ) SUB
    
    CC: not affected
    
    save result sign-extended to (ea) from ir[11:9]: An
        
    update PC 

if( (ir[15:12] == 4'b1011) && (ir[8:6] == 3'b011 || 3'b111) )
    CMPA
+++
    load (ea) from ir[5:0] to operand1: all modes
        all modes:                Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: An
    
    ALU operation size, source is sign-extended:
    if( ir[8] == 1'b0 ) word
    else if( ir[8] == 1'b1 ) long
    
    perform ALU operation:
    if( ir[14:12] == 3'b011 ) CMP==SUB
    
    CC: X not affected; C set if borrow else cleared; V set if overflow else cleared; Z set if zero else cleared; N set if negative else cleared
        
    update PC 
    
if( ((ir[15:12] == 4'b1100 || 4'b1000) && ir[8:4] == 5'b10000) || ((if[15:12] == 4'b1101 || 4'b1001) && (ir[8:4] == 5'b10000 || 5'b10100 || 5'b11000) )
    ABCD,SBCD,ADDX,SUBX
+++    
    load (ea) from ir[2:0] to operand1: Dn (ir[3] == 1'b0), -(An) (ir[3] == 1'b1)
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: Dn (ir[3] == 1'b0), -(An) (ir[3] == 1'b1)
    
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    perform ALU operation:
    if( ir[14:12] == 3'b100 ) ABCD
    else if( ir[14:12] == 3'b000 ) SBCD
    else if( ir[14:12] == 3'b101 ) ADDX
    else if( ir[14:12] == 3'b001 ) SUBX
    
    if( ir[12] == 1'b0 /ABCD,SBCD/ )
        CC: X=C set if decimal carry [borrow] else cleared; Z cleared if result nonzero else unchanged; N,V undefined
    else
        CC: X=C set if carry[borrow] else cleared; V set if overflow else cleared; Z cleared if nonzero else unchanged; N set if negative else cleared
    
    save result to (ea) from ir[11:9]: Dn (ir[3] == 1'b0), -(An) (ir[3] == 1'b1)
    
    update PC

if( ir[15:12] == 4'b1110 && ir[7:6] == 2'b11 && ir[11] == 1'b0 ) 
    ASL,LSL,ROL,ROXL,ASR,LSR,ROR,ROXR all memory
+++    
    load (ea) from ir[5:0] to operand1: memory alter
        memory alter:                                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    load 1'b1 to operand2
    
    ALU operation size: word
        
    ALU shift/rotate direction:
    if( ir[8] == 1'b0 ) right
    else if( ir[8] == 1'b1 ) left
    
    perform ALU operation:
    if( ir[10:9] == 2'b00 ) ASL/ASR
    else if( ir[10:9] == 2'b01 ) LSL,LSR
    else if( ir[10:9] == 2'b11 ) ROL,ROR
    else if( ir[10:9] == 2'b10 ) ROXL,ROXR
    
    CC: X set to last bit, unchanged if zero shift[same][not affected][same set]; N set if MSB bit is set else cleared; Z set if zero else cleared;
        V set if MSB bit changed during shift else cleared[cleared][cleared][cleared]; C set to last bit, cleared if zero shift[same][same][set to X]
    
    save result to (ea) from ir[5:0]: memory alter
        memory alter:                                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
    update PC
    
if( ir[15:12] == 4'b1110 && (ir[7:6] == 2'b00 || 2'b01 || 2'b10) )
    ASL,LSL,ROL,ROXL,ASR,LSR,ROR,ROXR all immediate/register
+++
    load (ea) from ir[11:9] to operand1: Dn
    
    move operand1 to operand2
    
    load (ea) from ir[2:0] to operand1: Dn
    
    if( ir[5] == 1'b0 )
        if( ir[11:9] == 3'b000 ) load 4'b1000 to operand2
        else load ir[11:9] to operand2
    else if( ir[5] == 1'b1 )
        perform operand2 modulo 64
    
    ALU operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    ALU shift/rotate direction:
    if( ir[8] == 1'b0 ) right
    else if( ir[8] == 1'b1 ) left
    
    perform ALU operation:
    if( ir[4:3] == 2'b00 ) ASL/ASR
    else if( ir[4:3] == 2'b01 ) LSL,LSR
    else if( ir[4:3] == 2'b11 ) ROL,ROR
    else if( ir[4:3] == 2'b10 ) ROXL,ROXR
    
    CC: X set to last bit, unchanged if zero shift[same][not affected][same set]; N set if MSB bit is set else cleared; Z set if zero else cleared;
        V set if MSB bit changed during shift else cleared[cleared][cleared][cleared]; C set to last bit, cleared if zero shift[same][same][set to X]
    
    save result to (ea) from ir[2:0]: Dn
    
    update PC

if( ir[15:12] == 4'b0111 && ir[8] == 1'b0 )
    MOVEQ
+++
    load ir[7:0] sign-extended to result register
    
    CC: X not affected; C cleared; V cleared; Z set if zero else cleared; N set if negative else cleared
    
    save result to (ea) from ir[11:9]: Dn
    
    update PC

if( ir[15:12] == 4'b0110 && ir[11:8] == 4'b0001 )
    BSR
+++
    CC: not affected
    
    SP -= 4
    
    move PC to operand1
    move operand1 to result
    
    save result to (ea): (SP)
    
    if( ir[7:0] == 8'b0 )
        add to PC: ir1[15:0]
    else
        add to PC: ir[7:0]
    
    return
    
if( ir[15:12] == 4'b0110 && ir[11:8] != 4'b0001 )
    Bcc,BRA
+++
    condition:                               high(!C & !Z) 0010, low or same(C | V) 0011,
                carry clear(!C) 0100, carry set(C) 0101, not equal(Z) 0110, equal(!Z) 0111,
                overflow clear(!V) 1000, overflow set(V) 1001, plus(!N) 1010, minus(N) 1011,
                greater or equal(N & V | !N & !V) 1100, less than(N & !V | !N & V) 1101,
                greater than(N & V & !Z | !N & !V & !Z) 1110, less or equal(Z | N & !V | !N & V) 1111

    CC: not affected
    
    if( contidtion on ir[11:8] true )
        if( ir[7:0] == 8'b0 )
            add to PC: ir1[15:0]
        else
            add to PC: ir[7:0]
            
        return
    
    update PC
    
if( ir[15:12] == 4'b0101 && ir[7:6] == 2'b11 && ir[5:3] != 2'b001 )
    Scc
+++
    condition:    true(1) 0000, false(0) 0001, high(!C & !Z) 0010, low or same(C | V) 0011,
                carry clear(!C) 0100, carry set(C) 0101, not equal(Z) 0110, equal(!Z) 0111,
                overflow clear(!V) 1000, overflow set(V) 1001, plus(!N) 1010, minus(N) 1011,
                greater or equal(N & V | !N & !V) 1100, less than(N & !V | !N & V),
                greater than(N & V & !Z | !N & !V & !Z), less or equal(Z | N & !V | !N & V) 1111
    
    if( contidtion on ir[11:8] false )
        load 8'b00000000 to result
    else
        load 8'b11111111 to result
    
    operation size: byte    
    
    save result to (ea) from ir[5:0]: data alter.
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    CC: not affected
    
    update PC
    
if( ir[15:12] == 4'b0101 && ir[7:6] == 2'b11 && ir[5:3] == 2'b001 )
    DBcc
+++
    condition:    true(1) 0000, false(0) 0001, high(!C & !Z) 0010, low or same(C | V) 0011,
                carry clear(!C) 0100, carry set(C) 0101, not equal(Z) 0110, equal(!Z) 0111,
                overflow clear(!V) 1000, overflow set(V) 1001, plus(!N) 1010, minus(N) 1011,
                greater or equal(N & V | !N & !V) 1100, less than(N & !V | !N & V),
                greater than(N & V & !Z | !N & !V & !Z), less or equal(Z | N & !V | !N & V) 1111
    
    CC: not affected
    
    if( condition on ir[11:8] false )
        load (ea) from ir[2:0] to operand1: Dn
    
        load 1'b1 to operand2
    
        ALU operation size: word
    
        perform ALU operation: SUB
    
        save result to (ea) from ir[2:0]: Dn
        
        if( result != -1 )
            add to PC: ir1[15:0]
            return
    
    update PC
    
if( ir[15:12] == 4'b0101 && ir[7:6] != 2'b11 && ir[5:3] != 3'b001 )
    ADDQ,SUBQ not An
+++
    if( ir[11:9] == 3'b000 )
        load 4'b1000 to operand2
    else
        load ir[11:9] to operand2
    
    load (ea) from by ir[5:0] to operand1: data alter
        data alter:                Dn 000,         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    ALU operation size:
    if( ir[7:6] == 2'b10 ) long
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b00 ) byte
    
    perform ALU operation:
    if( ir[8] == 1'b0 ) ADDQ
    else if( ir[8] == 1'b1 ) SUBQ
    
    CC: X=C set if carry[borrow] generated else cleared; V set if overflow else cleared; Z set if result zero else cleared;
        N set if result negative else cleared
    
    save result to (ea) from ir[5:0]
    
    update PC
    
if( ir[15:12] == 4'b0101 && ir[7:6] != 2'b11 && ir[5:3] == 3'b001)
    ADDQ,SUBQ An
+++
    if( ir[11:9] == 3'b000 )
        load 4'b1000 to operand2
    else
        load ir[11:9] to operand2
    
    load (ea) from by ir[2:0] to operand1: An
    
    ALU operation size: long
    
    perform ALU operation:
    if( ir[8] == 1'b0 ) ADD
    else if( ir[8] == 1'b1 ) SUB
    
    CC: not affected
    
    save result to (ea) from ir[2:0]: An
    
    update PC

if( ir[15:0] == 16'b0100 1110 0111 0001 )
    NOP
+++
    CC: not affected
    
    update PC

if( ir[15:0] == 16'b0100 1110 0111 0000 )
    RESET
+++
    hold REST output for 124 clock cycles
    
    CC: not affected
    
    update PC

if( ir[15:0] == 16'b0100 1110 0111 0010 )
    STOP
+++
    copy ir1[15:0] to SR
    
    Resume when trace, interrupt or rest.

if( ir[15:5] == 12'b0100 1110 0100 )
    TRAP
+++
    TRAP with vector indexed by ir[3:0]
    
    CC: not affected

if( ir[15:0] == 16'b0100 1110 0111 0110 )
    TRAPV
+++
    if( V ) TRAP
    
    CC: not affected
        
    update PC

if( ir[15:0] == 16'b0100 1110 0111 0011 || ir[15:0] == 16'b0100 1110 0111 0111 )
    RTE,RTR
+++
    load (ea) to operand1: (SP)
    
    perform ALU operation:
    if(ir[2] == 1'b0) move operand1 to SR
    else if(ir[2] == 1'b1) move operand1 to CCR
    
    SP += 2
    
    load (ea) to operand1: (SP)
    move operand1 to result
    move result to PC
    
    SP += 4

if( ir[15:0] == 16'b0100 1110 0111 0101 )
    RTS
+++
    load (ea) to operand1: (SP)
    move operand1 to result
    move result to PC
    
    SP += 4

if( ir[15:6] == 10'b0100 1110 11 )
    JMP
+++
    load (ea) from ir[5:0] to operand1: control
        control:                                         (An) 010,                       (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,         (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    perform ALU operation: move operand1 to result
    
    copy result register to PC
    
    CC: not affected

if( ir[15:6] == 10'b0100 1110 10 )
    JSR
+++
    SP -= 4
    
    move PC to operand1
    move operand1 to result
    save result to (ea): (SP)
    
    load (ea) from ir[5:0] to operand1: control
        control:                                         (An) 010,                       (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,         (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    perform ALU operation: move operand1 to result
    
    copy result register to PC
    
    CC: not affected

if( ir[15:3] == 13'b0100 1110 0101 0 )
    LINK
+++
    SP -= 4
    
    load (ea) from ir[2:0] to operand1: An
    
    perform ALU operation: move operand1 to result
    
    save result to (ea): (SP)
    
    load (ea) to operand1: SP
    move operand1 to result
    
    save result to (ea) from ir[2:0]: An
    
    add to SP: ir1[15:0]
    
    CC: not affected
    
    update PC

if( ir[15:3] == 13'b0100 1110 0101 1 )
    ULNK
+++
    load (ea) from ir[2:0] to operand1: An
    
    perform ALU operation: move operand1 to result
    
    save result to (ea): SP
    
    load ea to operand1: (SP)
    move operand1 to result
    
    save result to (ea) from ir[2:0]: An
    
    SP += 4
    
    CC: not affected
    
    update PC

if( ir[15:8] == 8'b0100 1010 && ir[7:6] != 2'b11 )
    TST
+++
    ea operation size:
    if( ir[7:6] == 2'b00 ) byte
    else if( ir[7:6] == 2'b01 ) word
    else if( ir[7:6] == 2'b10 ) long
    
    load (ea) from ir[5:0] to operand1: data alter
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    perform ALU TST operation: set CC
    
    CC: X not affected; C cleared; V cleared; Z set if zero else cleared; N set if MSB bit set else cleared
    
    update PC

if( ir[15:6] == 10'b0100 1010 11 && ir[5:0] != 6'b111000 )
    TAS
+++    
    ea operation size: byte
    
    enable READ-MODIFY-WRITE bus cycle
    
    load (ea) from ir[5:0] to operand1: data alter
        data alter:                Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    perform ALU TAS operation: set bit 7 in result register
    
    CC: X not affected; C cleared; V cleared; Z set if zero else cleared; N set if MSB bit set else cleared
        
    save result to (ea) from ir[5:0]: data alter
    
    disable READ-MODIFY-WRITE bus cycle
    
    update PC    

if( ir[15:12] == 4'b0100 && ir[8:6] == 3'b110 )
    CHK
+++
    load (ea) from ir[5:0] to operand1: data
        data:                     Dn 000,                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move operand1 to operand2
    
    load (ea) from ir[11:9] to operand1: Dn
    
    
    ALU operation size: word
    
    perform ALU CHK operation: operand1 < 0 or operand1 - operand2 > 0
    
    CC: X not affected; N set if operand1 < 0; cleared if operand1 - operand2 > 0 else undefined; C,V,Z udefined
    
    if( ALU check ) trap CHK
    
    update PC
    
if( ir[15:12] == 4'b0100 && ir[8:6] == 3'b111 )
    LEA
+++    
    load ea from ir[5:0] to address register: control
        control:                                     (An) 010,                       (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,         (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    move address register to operand1
    perform ALU operation: move operand1 to result register
    
    save result to (ea) from ir[11:9]: An
    
    CC: not affected
    
    update PC
    
if( ir[15:6] == 10'b0100 1000 01 && ir[5:3] != 3'b000 )
    PEA
+++    
    load ea from ir[5:0] to address register: control
        control:                                     (An) 010,                       (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,         (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    SP -= 4
    
    move address register to operand1
    move operand1 to result
    
    save result to (ea): (SP)
    
    CC: not affected
    
    update PC
    
if( ir[15:6] == 10'b0100 0100 11 || ir[15:6] == 10'b0100 0110 11 )
    MOVE TO CCR, MOVE TO SR
+++
    ea operation size: word
    
    load (ea) from ir[5:0] to operand1: data
        data:                    Dn 000,                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    if( ir[11:8] == 4'b0110 /MOVE TO SR/ )
        copy word form operand1 register to SR
    else
        copy lower byte form operand1 register to CCR
    
    update PC

if( ir[15:6] == 10'b0100 0000 11 )
    MOVE FROM SR
+++
    copy SR register to result register
    
    ea operation size: word
    
    save result to (ea) from ir[5:0]: data alter
        data alter:            Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                            (xxx).W 111 000, (xxx).L 111 001,
    
    CC: not affected
    
    update PC

if( ir[15:3] == 12'b0100 1110 0110 0 )
    MOVE USP to USP
+++
    load (ea) from ir[2:0] to operand1: An
    
    perform ALU operation: move operand1 to result
    
    move result to USP
    
    CC: not affected
    
    update PC

if( ir[15:3] == 13'b0100 1110 0110 1 )
    MOVE USP to An
+++
    move USP to operand1
    
    perform ALU operation: move operand1 to result
    
    save result to (ea) from ir[2:0]: An
    
    CC: not affected
    
    update PC

if( ir[15:12] == 4'b0100 && ( (ir[11:8] == 4'b0000 && ir[7:6] != 2'b11) || (ir[11:8] == 4'b0010) || (ir[11:8] == 4'b0100 && ir[7:6] != 2'b11) ||
    (ir[11:8] == 4'b0110 && ir[7:6] != 2'b11) || (ir[11:6] == 6'b1000 00) ) )
+++
    NEGX,CLR,NEG,NOT,NBCD
    
    load (ea) from ir[5:0] to operand1: data alter
    data alter:                    Dn 000,                 (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
                                
    ALU operation size:
    NEGX:    ir[7:6]: 00,01,10 byte,word,long
    CLR:    ir[7:6]: 00,01,10 byte,word,long
    NEG:    ir[7:6]: 00,01,10 byte,word,long
    NOT:    ir[7:6]: 00,01,10 byte,word,long
    NBCD:    ir[7:6]: 00 byte
    
    perform ALU operation:
    NEGX:    ir[11:8] == 4'b0000
    CLR:    ir[11:8] == 4'b0010
    NEG:    ir[11:8] == 4'b0100
    NOT:    ir[11:8] == 4'b0110
    NBCD:    ir[11:6] == 6'b1000 00
    
    CC:
    NEGX:    X=C set if borrow else clear; V set if overflow else clear; Z cleared if nonzero else unchanged; N set if negative else clear
    CLR:    X not affected; C cleared; V cleared; Z set; N cleared
    NEG:    X=C clear if zero else set; V set if overflow else clear; Z set if zero else clear; N set if negative else clear
    NOT:    X not affected; C cleared; V cleared; Z set if zero else cleared; N set if negative else cleared
    NBCD:    X=C set if decimal borrow else cleared; Z cleared if nonzero else unchanged; N,V undefined
    
    save result to (ea) from ir[5:0]: data alter
    
    update PC

if( ir[15:12] == 4'b0100 && (ir[11:3] == 9'b1000 01 000 || (ir[11:7] == 5'b1000 1 && ir[5:3] == 3'b000) )
    SWAP,EXT
+++
    load (ea) from ir[5:0] to operand1: Dn
            
    ALU operation size: word
    SWAP:     ir[7:6]: 01 long
    EXT:    ir[7:6]: 10,11 byte to word, word to long
    
    perform ALU operation:
    SWAP:     ir[11:6] == 6'b1000 01
    EXT:    ir[11:7] == 5'b1000 1
    
    CC:
    SWAP:    X not affected; C cleared; V cleared; Z set if 32 bits are zero else cleared; N set if result MSB set else cleared
    EXT:    X not affected; C cleared; V cleared; Z set if zero else cleared; N set if negative else cleared
    
    save result to (ea) from ir[5:0]: Dn
    
    update PC

if( ir[15:7] == 9'b0100 1100 1 && ir[5:3] != 3'b000 )
    MOVEM memory to register
+++
    operation size:
    if( ir[6] == 1'b0 ) word
    else if ir[6] == 1'b1 ) long
    
    load ea from ir[5:0] to address register: control or postincrement
                                                (An) 010, (An)+ 011,            (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,                (d16, PC) 111 010, (d8, PC, Xn) 111 011
    
    register selection order: D0,D1,...D7,A0,A1,...,A7
    
    do
        if( ir1[0] == 1'b1 ) 
            read from (ea) to operand1
            
            perform ALU operation: move operand1 with sign-extension to result
            
            save result to selected register
            
            update address register
            
        shift ir1
    loop 16 times
    
    if( ir[5:3] == 3'b011 ) save address register back to An indexed by ir[2:0]
    
    CC: not affected
    
    update PC

if( ir[15:7] == 9'b0100 1000 1 && ir[5:3] == 3'b100 )
    MOVEM register to memory, predecrement
+++    
    operation size:
    if( ir[6] == 1'b0 ) word
    else if ir[6] == 1'b1 ) long
    
    load ea from ir[5:0] to address register: control alter or predecrement
                                        (An) 010,            -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    register selection order: A7,A6,..A0,D7,D6,....D0
    
    do
        if( ir1[0] == 1'b1 ) 
            save selected register to operand1
            
            perform ALU operation: move operand1 to result
        
            save result to (ea)
        
            update address register
    
        shift ir1
    loop 16 times
    
    if( ir[5:3] == 3'b100 ) save address register back to An indexed by ir[2:0]
    
    CC: not affected
    
    update PC

if( ir[15:7] == 9'b0100 1000 1 && ir[5:3] != 3'b000 && ir[5:3] != 3b100 )
    MOVEM register to memory, control
+++    
    operation size:
    if( ir[6] == 1'b0 ) word
    else if ir[6] == 1'b1 ) long
    
    load ea from ir[5:0] to address register: control alter or predecrement
                                        (An) 010,            -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
    
    register selection order: D0,D1,...D7,A0,A1,...,A7
    
    do
        if( ir1[0] == 1'b1 ) 
            save selected register to operand1
            
            perform ALU operation: move operand1 to result
        
            save result to (ea)
        
            update address register
    
        shift ir1
    loop 16 times
    
    CC: not affected
    
    update PC

*/

/*

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
microinstructions

MOVE_ea_reg_TO_An_address
MOVE_ea_reg_TO_Dn_address
MOVE_ir1_brief_ext_TO_An_Dn_addresses        // ir_valid
MOVE_An_output_TO_address
MOVE_Dn_output_TO_OP1
MOVE_An_output_TO_OP1
MOVE_zeros_TO_index
MOVE_ir1_brief_ext_TO_index                    // ir_valid
MOVE_ir1_byte_TO_offset                        // ir_valid
MOVE_ir1_word_TO_offset                        // ir_valid
MOVE_base_index_offset_TO_address
MOVE_ir1_absolute_word_TO_address            // ir_valid
MOVE_ir1_ir2_absolute_long_TO_address        // ir_valid
MOVE_pc_index_offset_TO_address
MOVE_trap_TO_address
MOVE_result_TO_An_input
MOVE_result_TO_Dn_input(size=)
MOVE_address_TO_An_input
MOVE_result_TO_data

MOVE_OP1_TO_OP2
MOVE_OP2_TO_OP1
MOVE_ADDR_TO_OP1
MOVE_data_TO_OP1
MOVE_immediate_TO_OP1(size=)
MOVE_result_TO_OP1
MOVE_moveq_TO_OP1
MOVE_PC_NEXT_TO_OP1
MOVE_zeros_TO_OP1
MOVE_ones_TO_OP1
MOVE_SR_TO_OP1
MOVE_USP_TO_OP1
MOVE_ir_TO_OP1
MOVE_address_bus_info_TO_OP2
MOVE_1_TO_OP2
MOVE_offset_TO_OP2
MOVE_count_TO_OP2
MOVE_addq_subq_TO_OP2
MOVE_result_TO_PC
MOVE_result_TO_USP
MOVE_zeros_TO_movem_mod_reg
MOVE_001111_TO_movem_mod_reg
MOVE_OP1_TO_movem_reg
MOVE_zeros_TO_movem_loop
MOVE_prefetch_ir_TO_ir
MOVE_interrupt_mask_TO_sr
MOVE_1_0_supervisor_trace_TO_sr
MOVE_reset_mask_TO_sr
MOVE_prefetch_ir_TO_PC
MOVE_prefetch_ir_TO_SSP

MOVE_illegal_instr_TO_TRAP
MOVE_divide_by_zero_TO_TRAP
MOVE_chk_TO_TRAP
MOVE_trapv_TO_TRAP
MOVE_priv_viol_TO_TRAP
MOVE_trap_TO_TRAP
MOVE_decoder_trap_TO_TRAP
MOVE_trace_TO_TRAP
MOVE_interrupt_trap_TO_TRAP

MOVE_0_TO_stop_flag
MOVE_1_TO_stop_flag
MOVE_sr15_TO_trace_flag
MOVE_0_TO_group_0_flag
MOVE_1_TO_group_0_flag
MOVE_0_TO_read_modify_write_flag
MOVE_1_TO_read_modify_write_flag
MOVE_0_TO_instruction_flag
MOVE_1_TO_instruction_flag
MOVE_1_TO_blocked_flag
MOVE_0_TO_read_flag
MOVE_1_To_read_flag
MOVE_0_TO_write_flag
MOVE_1_TO_write_flag
MOVE_0_TO_interrupt_flag
MOVE_1_TO_interrupt_flag
MOVE_1_TO_reset_flag
MOVE_0_TO_reset_flag

INCR_ADDR_BY_SIZE(size=)
DECR_ADDR_BY_SIZE(size=)
DECR_OP2_BY_1
CALL procedure
RETURN
INCR_movem_loop_BY_1
INCR_movem_mod_reg_BY_1
DECR_movem_mod_reg_BY_1
JMP: local label, trap, instr_fin, instr_fin_pc_loaded,
SHIFT_RIGHT_movem_reg
INCR_PC_BY_2
INCR_PC_BY_4
INCR_PC_BY_size(size=)

BRANCH(movem_loop == 4'b1000)
BRANCH(movem_reg[0] == 0)
BRANCH(operand2[5:0] == 6'b0)
BRANCH(special == 2'b01)
BRANCH(special == 2'b10)
BRANCH(condition == 1'b0)
BRANCH(condition == 1'b1)
BRANCH(result[15:0] == 16'hFFFF)
BRANCH(V == 1'b0)
BRANCH(stop_flag == 1'b1)
BRANCH(ir[7:0] != 8'b0)
BRANCH(decoder_trap == 8'b0)
BRANCH(trace_flag == 1'b0)
BRANCH(group_0_flag == 0)

WAIT_RESET, WAIT_MEMORY_READ(size, address), WAIT_MEMORY_WRITE(size, address, select), WAIT_interrupt, WAIT_blocked
WAIT_prefetch_ir_valid

subprocedures:
ea(size=, reg=, mod=, type=, select=)

LOAD_EA:             to address register
PERFORM_EA_READ:     to operand1
PERFORM_EA_WRITE:     from result
SAVE_EA

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

TYPE.ALL: all
                                Dn 000,    An (word, long) 001, (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011
TYPE.CONTROL_POSTINC: control or postincrement
                                                             (An) 010, (An)+ 011,            (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,                (d16, PC) 111 010, (d8, PC, Xn) 111 011
TYPE.CONTROLALTER_PREDEC: control alter or predecrement
                                                              (An) 010,            -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
TYPE.CONTROL: control
                                                              (An) 010,                       (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,                  (d16, PC) 111 010, (d8, PC, Xn) 111 011
TYPE.DATAALTER: data alter
                                Dn 000,                      (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001,
TYPE.DN_AN: Dn, An
                                Dn 000, An 001
TYPE.MEMORYALTER: memory alter
                                                              (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001
TYPE.DATA: data
                                Dn 000,                         (An) 010, (An)+ 011, -(An) 100, (d16, An) 101, (d8, An, Xn) 110,
                                (xxx).W 111 000, (xxx).L 111 001, #data 111 100, (d16, PC) 111 010, (d8, PC, Xn) 111 011


