<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ao68000: Microcode</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Design&#160;Unit&#160;List</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">index</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Microcode </h1>  </div>
</div>
<div class="contents">
<p>The listing below represents the microcode. It is taken from <code>./sw/ao68000_tool/Microcode.java</code>. More information about the microcode structure and compilation is available at <a class="el" href="page_microcode_compilation.html">Microcode compilation</a>.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright 2010, Aleksander Osman, alfik@poczta.fm. All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without modification, are</span>
<span class="comment"> * permitted provided that the following conditions are met:</span>
<span class="comment"> *</span>
<span class="comment"> *  1. Redistributions of source code must retain the above copyright notice, this list of</span>
<span class="comment"> *     conditions and the following disclaimer.</span>
<span class="comment"> *</span>
<span class="comment"> *  2. Redistributions in binary form must reproduce the above copyright notice, this list</span>
<span class="comment"> *     of conditions and the following disclaimer in the documentation and/or other materials</span>
<span class="comment"> *     provided with the distribution.</span>
<span class="comment"> *</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND</span>
<span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR</span>
<span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="comment"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
<span class="comment"> * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="comment"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF</span>
<span class="comment"> * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> */</span>

<span class="keyword">package </span>ao68000_tool;

<span class="keyword">public</span> <span class="keyword">class </span>Microcode {
    <span class="keyword">static</span> <span class="keywordtype">void</span> microcode(Parser p) <span class="keywordflow">throws</span> Exception {

        p.label(<span class="stringliteral">&quot;reset&quot;</span>);
        
        p       .GROUP_0_FLAG_SET();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

                <span class="comment">// move SSP and PC from prefetch</span>
        p       .AN_INPUT_FROM_PREFETCH_IR().AN_ADDRESS_SSP().AN_WRITE_ENABLE_SET()
                .PC_FROM_PREFETCH_IR()
                <span class="comment">// jump to main loop</span>
                .BRANCH_procedure().PROCEDURE_jump_to_main_loop();
                

        p.label(<span class="stringliteral">&quot;MICROPC_ADDRESS_BUS_TRAP&quot;</span>);

                <span class="comment">// save trap number and bus cycle extended information</span>
        p       .TRAP_FROM_INTERRUPT()
                .OP2_MOVE_ADDRESS_BUS_INFO()
                <span class="comment">// clear internal flags</span>
                .READ_MODIFY_WRITE_FLAG_CLEAR()
                .INSTRUCTION_FLAG_SET()
                .DO_READ_FLAG_CLEAR()
                .DO_WRITE_FLAG_CLEAR()
                .DO_INTERRUPT_FLAG_CLEAR()

                <span class="comment">// check if group_0_flag already active</span>
                .BRANCH_group_0_flag().offset(<span class="stringliteral">&quot;address_bus_trap_group_0_flag_cleared&quot;</span>);

                        <span class="comment">// if group_0_flag active: block processor</span>
        p               .DO_BLOCKED_FLAG_SET()
                        .BRANCH_procedure()
                        .PROCEDURE_wait_finished();

                <span class="comment">// continue processing trap</span>
        p       .label(<span class="stringliteral">&quot;address_bus_trap_group_0_flag_cleared&quot;</span>);
        p       .GROUP_0_FLAG_SET();

        <span class="comment">//--</span>
                <span class="comment">// move PC to OP1</span>
        p       .OP1_FROM_PC();
                <span class="comment">// move OP1 to result</span>
        p       .ALU_SIMPLE_MOVE()
                <span class="comment">// move SR to OP1</span>
                .OP1_FROM_SR();

                <span class="comment">// set supervisor, clear trace</span>
        p       .ALU_SR_SET_TRAP();

        <span class="comment">//--</span>
                <span class="comment">// stack PC</span>
        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea()
                <span class="comment">// move SR to result</span>
                .ALU_SIMPLE_MOVE()
                <span class="comment">// move IR to OP1</span>
                .OP1_FROM_IR();

                <span class="comment">// stack SR</span>
        p       .SIZE_WORD().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea()
                <span class="comment">// move IR to result</span>
                .ALU_SIMPLE_MOVE()
                <span class="comment">// move fault address to OP1</span>
                .OP1_FROM_FAULT_ADDRESS();

        <span class="comment">//--</span>
                <span class="comment">// stack IR</span>
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea()
                <span class="comment">// move fault address to result</span>
                .ALU_SIMPLE_MOVE()
                <span class="comment">// move bus cycle info stored in OP2 to OP1</span>
                .OP1_FROM_OP2();

                <span class="comment">// stack fault address</span>
        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea()
                <span class="comment">// move bus cycle info from OP1 to result</span>
                .ALU_SIMPLE_MOVE();

                <span class="comment">// stack bus cycle info</span>
        p       .SIZE_WORD().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        <span class="comment">//--</span>
                <span class="comment">// load PC from exception vector table</span>
        p       .ADDRESS_FROM_TRAP()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();
        p       .ALU_SIMPLE_MOVE();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .PC_FROM_RESULT();

                <span class="comment">// wait one cycle to check loaded PC: is it even ?</span>
        p       .OP1_FROM_OP2();
        <span class="comment">//--</span>
                <span class="comment">// jump to main loop</span>
        p       .BRANCH_procedure().PROCEDURE_jump_to_main_loop();

        p.label(<span class="stringliteral">&quot;MICROPC_TRAP_ENTRY&quot;</span>);

        <span class="comment">//--</span>
                <span class="comment">// move PC to OP1</span>
        p       .OP1_FROM_PC();
                <span class="comment">// move OP1 to result</span>
        p       .ALU_SIMPLE_MOVE()
                <span class="comment">// move SR to OP1</span>
                .OP1_FROM_SR();

                <span class="comment">// set supervisor, clear trace</span>
        p       .ALU_SR_SET_TRAP();

        <span class="comment">//--</span>
                <span class="comment">// stack PC</span>
        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea()
                <span class="comment">// move SR to result</span>
                .ALU_SIMPLE_MOVE();

                <span class="comment">// stack SR</span>
        p       .SIZE_WORD().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        <span class="comment">//--</span>
                <span class="comment">// load PC from exception vector table</span>
        p       .ADDRESS_FROM_TRAP()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();
        p       .ALU_SIMPLE_MOVE();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .PC_FROM_RESULT();

                <span class="comment">// wait one cycle to check loaded PC: is it even ?</span>
        p       .OP1_FROM_OP2();
        
        <span class="comment">//--</span>
                <span class="comment">// return</span>
        p       .BRANCH_procedure().PROCEDURE_return();
        

        p.label(<span class="stringliteral">&quot;MICROPC_MAIN_LOOP&quot;</span>);

                <span class="comment">// check if stop flag set and wait for valid prefetch and decode instruction</span>
                <span class="comment">// execute instruction, instruction generated trap possible</span>
        p       .BRANCH_stop_flag_wait_ir_decode().offset(<span class="stringliteral">&quot;main_loop_after_execution&quot;</span>)
                <span class="comment">// clear read-modify-write flag always</span>
                .READ_MODIFY_WRITE_FLAG_CLEAR()

                <span class="comment">// save trace flag, only when valid prefetch and valid instruction and stop flag cleared</span>
                .TRACE_FLAG_COPY_WHEN_NO_STOP()

                <span class="comment">// save first instruction word, only when prefetch valid and stop flag cleared</span>
                .IR_LOAD_WHEN_PREFETCH_VALID()
                <span class="comment">// clear group 0 flag, only when valid prefetch and stop flag cleared</span>
                .GROUP_0_FLAG_CLEAR_WHEN_VALID_PREFETCH()

                <span class="comment">// increment PC by 2, only when valid prefetch and valid instruction and stop flag cleared</span>
                .PC_INCR_BY_2_IN_MAIN_LOOP()
                <span class="comment">// clear instruction flag, only when valid prefetch and valid instruction and stop flag cleared</span>
                .INSTRUCTION_FLAG_CLEAR_IN_MAIN_LOOP();
                
                        <span class="comment">// call trap</span>
        p               .TRAP_FROM_DECODER()
                        .INSTRUCTION_FLAG_SET()
                        .BRANCH_procedure().PROCEDURE_call_trap();
                                <span class="comment">// after trap jump to main loop</span>
        p                       .BRANCH_procedure().PROCEDURE_jump_to_main_loop();

                <span class="comment">// jump here after execution</span>
        p       .label(<span class="stringliteral">&quot;main_loop_after_execution&quot;</span>);

                <span class="comment">// check if trace flag set and check external interrupt</span>
        p       .BRANCH_trace_flag_and_interrupt().offset(<span class="stringliteral">&quot;main_loop_interrupt&quot;</span>)
                <span class="comment">// set instruction flag, always</span>
                .INSTRUCTION_FLAG_SET();
        
                        <span class="comment">// call trap</span>
        p               .TRAP_TRACE()
                        .STOP_FLAG_CLEAR()
                        .BRANCH_procedure().PROCEDURE_call_trap();
                        <span class="comment">// after trap continue</span>

                <span class="comment">// jump here if trace flag not set and interupt pending</span>
        p       .label(<span class="stringliteral">&quot;main_loop_interrupt&quot;</span>);

                <span class="comment">// check external interrupt</span>
        p       .DO_INTERRUPT_FLAG_SET_IF_ACTIVE()
                .BRANCH_procedure().PROCEDURE_interrupt_mask();

        p               .BRANCH_procedure().PROCEDURE_wait_finished()
                        .ALU_SR_SET_INTERRUPT();

        p               .DO_INTERRUPT_FLAG_CLEAR()
                        .TRAP_FROM_INTERRUPT()
                        .STOP_FLAG_CLEAR()
                        .BRANCH_procedure().PROCEDURE_call_trap();

                        <span class="comment">// after trap jump to main loop</span>
                        p       .BRANCH_procedure().PROCEDURE_jump_to_main_loop();

        <span class="comment">// **************************************************************** EA</span>

        <span class="comment">// load ea: to address register</span>

        <span class="comment">// (An), (An)+:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_An&quot;</span>);
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_An_plus&quot;</span>);

        p       .ADDRESS_FROM_AN_OUTPUT()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// -(An):</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_minus_An&quot;</span>);

        p       .ADDRESS_FROM_AN_OUTPUT();
        p       .ADDRESS_DECR_BY_SIZE()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// (d16, An):</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_d16_An&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();
        
        p       .INDEX_0()
                .OFFSET_IMM_16()
                .PC_INCR_BY_2()
                .ADDRESS_FROM_AN_OUTPUT();

        p       .ADDRESS_FROM_BASE_INDEX_OFFSET()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// (d8, An, Xn):</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_d8_An_Xn&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid()
                .ADDRESS_FROM_AN_OUTPUT();

        p       .AN_ADDRESS_FROM_EXTENDED()
                .DN_ADDRESS_FROM_EXTENDED()
                .OFFSET_IMM_8();

        p       .AN_ADDRESS_FROM_EXTENDED()
                .INDEX_LOAD_EXTENDED()
                .PC_INCR_BY_2();

        p       .ADDRESS_FROM_BASE_INDEX_OFFSET()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// (xxx).W:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_xxx_W&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .ADDRESS_FROM_IMM_16()
                .PC_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// (xxx).L:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_xxx_L&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .ADDRESS_FROM_IMM_32()
                .PC_INCR_BY_4()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// (d16, PC):</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_d16_PC&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .INDEX_0()
                .OFFSET_IMM_16();

        p       .ADDRESS_FROM_PC_INDEX_OFFSET()
                .PC_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_return();
                
        <span class="comment">// (d8, PC, Xn):</span>
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_d8_PC_Xn&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .AN_ADDRESS_FROM_EXTENDED()
                .DN_ADDRESS_FROM_EXTENDED()
                .OFFSET_IMM_8();

        p       .AN_ADDRESS_FROM_EXTENDED()
                .INDEX_LOAD_EXTENDED();

        p       .ADDRESS_FROM_PC_INDEX_OFFSET()
                .PC_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_return();
        
        p.label(<span class="stringliteral">&quot;MICROPC_LOAD_EA_illegal_command&quot;</span>);

                <span class="comment">// call trap</span>
        p       .TRAP_ILLEGAL_INSTR()
                .BRANCH_procedure().PROCEDURE_call_trap();
                <span class="comment">// after trap jump to main loop</span>
        p       .BRANCH_procedure().PROCEDURE_jump_to_main_loop();

        
        <span class="comment">// perform_ea_read: memory, Dn,An,immediate</span>

        <span class="comment">// Dn:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_READ_Dn&quot;</span>);

        p       .OP1_FROM_DN()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// An:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_READ_An&quot;</span>);

        p       .OP1_FROM_AN()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// immediate</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_READ_imm&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// memory</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_READ_memory&quot;</span>);

        p       .DO_READ_FLAG_SET()
                .BRANCH_procedure().PROCEDURE_wait_finished();

        p       .DO_READ_FLAG_CLEAR()
                .OP1_FROM_DATA()
                .BRANCH_procedure().PROCEDURE_return();
        
        <span class="comment">// perform ea write: memory, Dn,An</span>
        <span class="comment">// size of operand matters: select in memory write</span>
        
        <span class="comment">// Dn:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_WRITE_Dn&quot;</span>);

        p       .DN_WRITE_ENABLE_SET()
                .BRANCH_procedure().PROCEDURE_return();
        

        <span class="comment">// An:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_WRITE_An&quot;</span>);

        p       .AN_WRITE_ENABLE_SET()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// memory:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_PERFORM_EA_WRITE_memory&quot;</span>);

        p       .DATA_WRITE_FROM_RESULT()
                .DO_WRITE_FLAG_SET()
                .BRANCH_procedure().PROCEDURE_wait_finished();

        p       .DO_WRITE_FLAG_CLEAR()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// save ea: (An)+,-(An)</span>

        <span class="comment">// (An)+:</span>
        p.label(<span class="stringliteral">&quot;MICROPC_SAVE_EA_An_plus&quot;</span>);

        p       .ADDRESS_INCR_BY_SIZE();

        p       .AN_INPUT_FROM_ADDRESS()
                .AN_WRITE_ENABLE_SET()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// -(An)</span>
        p.label(<span class="stringliteral">&quot;MICROPC_SAVE_EA_minus_An&quot;</span>);

        p       .AN_INPUT_FROM_ADDRESS()
                .AN_WRITE_ENABLE_SET()
                .BRANCH_procedure().PROCEDURE_return();

        <span class="comment">// **************************************************************** Instructions</span>

        p.label(<span class="stringliteral">&quot;MICROPC_MOVEP_memory_to_register&quot;</span>);

        p       .SIZE_BYTE().EA_REG_IR_2_0().EA_MOD_INDIRECTOFFSET().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_MOVEP_M2R_1()
                .ADDRESS_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_MOVEP_M2R_2()
                .ADDRESS_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_MOVEP_M2R_3()
                .ADDRESS_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_MOVEP_M2R_4()
                .SIZE_1().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVEP_register_to_memory&quot;</span>);

        p       .SIZE_1_PLUS().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .SIZE_BYTE().EA_REG_IR_2_0().EA_MOD_INDIRECTOFFSET().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .ALU_MOVEP_R2M_1()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .ADDRESS_INCR_BY_2()
                .ALU_MOVEP_R2M_2()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_movep_16().offset(<span class="stringliteral">&quot;movep_16&quot;</span>);

        p               .ADDRESS_INCR_BY_2()
                        .ALU_MOVEP_R2M_3()
                        .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p               .ADDRESS_INCR_BY_2()
                        .ALU_MOVEP_R2M_4()
                        .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

                <span class="comment">// jump here if word operation</span>
        p       .label(<span class="stringliteral">&quot;movep_16&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVEM_memory_to_register&quot;</span>);

        p       .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();

        p       .MOVEM_REG_FROM_OP1()
                .MOVEM_MODREG_LOAD_0()
                .MOVEM_LOOP_LOAD_0()
                .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL_POSTINC();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

                <span class="comment">// push current micro pc on stack</span>
        p       .BRANCH_procedure().PROCEDURE_push_micropc();

                <span class="comment">// check if loop finished</span>
        p       .BRANCH_movem_loop().offset(<span class="stringliteral">&quot;movem_memory_to_register_loop&quot;</span>);

                        <span class="comment">// check if operation on register required</span>
        p               .BRANCH_movem_reg().offset(<span class="stringliteral">&quot;movem_memory_to_register_reg&quot;</span>);

        p                       .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL_POSTINC();
        p                       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p                       .ALU_SIGN_EXTEND()
                                .ADDRESS_INCR_BY_SIZE()
                                .SIZE_LONG().EA_REG_MOVEM_REG_2_0().EA_MOD_MOVEM_MOD_5_3().EA_TYPE_DN_AN();
        p                       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

                        <span class="comment">// jump here if operation on register not required</span>
        p               .label(<span class="stringliteral">&quot;movem_memory_to_register_reg&quot;</span>);

        p               .MOVEM_MODREG_INCR_BY_1()
                        .MOVEM_REG_SHIFT_RIGHT()
                        .MOVEM_LOOP_INCR_BY_1()
                        .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if loop finished</span>
        p       .label(<span class="stringliteral">&quot;movem_memory_to_register_loop&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_pop_micropc()
                .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL_POSTINC();

        p       .BRANCH_procedure().PROCEDURE_call_save_ea()
                .ADDRESS_DECR_BY_SIZE();

        p       .BRANCH_procedure().PROCEDURE_return();
        
        p.label(<span class="stringliteral">&quot;MICROPC_MOVEM_register_to_memory_predecrement&quot;</span>);

        p       .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();
        
        p       .MOVEM_REG_FROM_OP1()
                .MOVEM_MODREG_LOAD_6b001111()
                .MOVEM_LOOP_LOAD_0()
                .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROLALTER_PREDEC();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

                <span class="comment">// push current micro pc on stack</span>
        p       .BRANCH_procedure().PROCEDURE_push_micropc();

                 <span class="comment">// check if loop finished</span>
        p       .BRANCH_movem_loop().offset(<span class="stringliteral">&quot;movem_register_to_memory_predecrement_loop&quot;</span>);

                        <span class="comment">// check if operation on register required</span>
        p               .BRANCH_movem_reg().offset(<span class="stringliteral">&quot;movem_register_to_memory_predecrement_reg&quot;</span>);

        p                       .SIZE_2().EA_REG_MOVEM_REG_2_0().EA_MOD_MOVEM_MOD_5_3().EA_TYPE_DN_AN();
        p                       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p                       .ALU_SIGN_EXTEND()
                                .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROLALTER_PREDEC();
        p                       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p                       .ADDRESS_DECR_BY_SIZE();

                        <span class="comment">// jump here if operation on register not required</span>
        p               .label(<span class="stringliteral">&quot;movem_register_to_memory_predecrement_reg&quot;</span>);

        p               .MOVEM_MODREG_DECR_BY_1()
                        .MOVEM_REG_SHIFT_RIGHT()
                        .MOVEM_LOOP_INCR_BY_1()
                        .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if loop finished</span>
        p       .label(<span class="stringliteral">&quot;movem_register_to_memory_predecrement_loop&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_pop_micropc()
                .ADDRESS_INCR_BY_SIZE();

        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVEM_register_to_memory_control&quot;</span>);

        p       .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();

        p       .MOVEM_REG_FROM_OP1()
                .MOVEM_MODREG_LOAD_0()
                .MOVEM_LOOP_LOAD_0()
                .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROLALTER_PREDEC();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

                <span class="comment">// push current micro pc on stack</span>
        p       .BRANCH_procedure().PROCEDURE_push_micropc();

                 <span class="comment">// check if loop finished</span>
        p       .BRANCH_movem_loop().offset(<span class="stringliteral">&quot;movem_register_to_memory_control_loop&quot;</span>);

                        <span class="comment">// check if operation on register required</span>
        p               .BRANCH_movem_reg().offset(<span class="stringliteral">&quot;movem_register_to_memory_control_reg&quot;</span>);

        p                       .SIZE_2().EA_REG_MOVEM_REG_2_0().EA_MOD_MOVEM_MOD_5_3().EA_TYPE_DN_AN();
        p                       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p                       .ALU_SIGN_EXTEND()
                                .SIZE_2().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROLALTER_PREDEC();
        p                       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p                       .ADDRESS_INCR_BY_SIZE();

                        <span class="comment">// jump here if operation on register not required</span>
        p               .label(<span class="stringliteral">&quot;movem_register_to_memory_control_reg&quot;</span>);

        p               .MOVEM_MODREG_INCR_BY_1()
                        .MOVEM_REG_SHIFT_RIGHT()
                        .MOVEM_LOOP_INCR_BY_1()
                        .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if loop finished</span>
        p       .label(<span class="stringliteral">&quot;movem_register_to_memory_control_loop&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_pop_micropc();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_LEA&quot;</span>);

        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .OP1_FROM_ADDRESS();

        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_IR_11_9().EA_MOD_AN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_PEA&quot;</span>);

        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .OP1_FROM_ADDRESS();

        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_ANDI_EORI_ORI_ADDI_SUBI&quot;</span>);
<span class="comment">//+++</span>
        p       .SIZE_3().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE()
                
                .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .OP2_FROM_OP1()
                .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_ORI_to_CCR_ORI_to_SR_ANDI_to_CCR_ANDI_to_SR_EORI_to_CCR_EORI_to_SR&quot;</span>);
<span class="comment">//+</span>
        p       .SIZE_3().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();

        p       .OP2_FROM_OP1()
                .OP1_FROM_SR();

        p       .ALU_ARITHMETIC_LOGIC();

        p       .OP1_FROM_RESULT();

        p       .ALU_MOVE_TO_CCR_SR_RTE_RTR_STOP_LOGIC_TO_CCR_SR()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_CMPI&quot;</span>);
<span class="comment">//+</span>
        p       .SIZE_3().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE()

                .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .OP2_FROM_OP1()
                .BRANCH_procedure().PROCEDURE_call_read();
        
        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_save_ea();     

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_ABCD_SBCD_ADDX_SUBX&quot;</span>);

        p       .SIZE_3().EA_REG_IR_2_0().EA_MOD_DN_PREDEC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_11_9().EA_MOD_DN_PREDEC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_ABCD_SBCD_ADDX_SUBX_prepare();
        p       .ALU_ABCD_SBCD_ADDX_SUBX()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_EXG&quot;</span>);

        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DN_AN();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_IR_11_9().EA_MOD_DN_AN_EXG().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DN_AN();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();


        p.label(<span class="stringliteral">&quot;MICROPC_CMPM&quot;</span>);

        p       .SIZE_3().EA_REG_IR_2_0().EA_MOD_POSTINC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_11_9().EA_MOD_POSTINC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_ASL_LSL_ROL_ROXL_ASR_LSR_ROR_ROXR_all_immediate_register&quot;</span>);

        p       .SIZE_3().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_2_0().EA_MOD_DN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .OP2_LOAD_COUNT();

        p       .ALU_ASL_LSL_ROL_ROXL_ASR_LSR_ROR_ROXR_prepare();

        p       .BRANCH_procedure().PROCEDURE_push_micropc();

        p       .BRANCH_operand2().offset(<span class="stringliteral">&quot;shift_rotate_immediate_loop&quot;</span>);

        p               .ALU_ASL_LSL_ROL_ROXL_ASR_LSR_ROR_ROXR();
        p               .OP1_FROM_RESULT()
                        .OP2_DECR_BY_1()
                        .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if loop finished</span>
        p       .label(<span class="stringliteral">&quot;shift_rotate_immediate_loop&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_pop_micropc();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_ASL_LSL_ROL_ROXL_ASR_LSR_ROR_ROXR_all_memory&quot;</span>);

        p       .SIZE_WORD().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_MEMORYALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .OP2_LOAD_1();

        p       .ALU_ASL_LSL_ROL_ROXL_ASR_LSR_ROR_ROXR_prepare();
        p       .ALU_ASL_LSL_ROL_ROXL_ASR_LSR_ROR_ROXR();

        p       .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVE&quot;</span>);

        p       .SIZE_4().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_SIMPLE_MOVE()
                .SIZE_4().EA_REG_IR_11_9().EA_MOD_IR_8_6().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();
        p       .ALU_MOVE()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVEA&quot;</span>);

        p       .SIZE_4().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_SIGN_EXTEND()
                .SIZE_4().EA_REG_IR_11_9().EA_MOD_AN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_EOR&quot;</span>);

        p       .SIZE_3().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_ADD_to_mem_SUB_to_mem_AND_to_mem_OR_to_mem&quot;</span>);

        p       .SIZE_3().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_MEMORYALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_ADD_to_Dn_SUB_to_Dn_AND_to_Dn_OR_to_Dn&quot;</span>);

        p       .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_CMP&quot;</span>);

        p       .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_3().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_ADDA_SUBA&quot;</span>);

        p       .SIZE_5().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_LONG().EA_REG_IR_11_9().EA_MOD_AN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_ADDA_SUBA_CMPA_ADDQ_SUBQ()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_CMPA&quot;</span>);

        p       .SIZE_5().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_LONG().EA_REG_IR_11_9().EA_MOD_AN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_ADDA_SUBA_CMPA_ADDQ_SUBQ()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_CHK&quot;</span>);

        p       .SIZE_WORD().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATA();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_WORD().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_CHK();

        p       .BRANCH_alu_signal().offset(<span class="stringliteral">&quot;chk_no_trap&quot;</span>);
        p               .TRAP_CHK()
                        .BRANCH_procedure().PROCEDURE_call_trap();
                        <span class="comment">// after return continue</span>
        
                <span class="comment">// jump here if no trap</span>
        p       .label(<span class="stringliteral">&quot;chk_no_trap&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_MULS_MULU_DIVS_DIVU&quot;</span>);

        p       .SIZE_WORD().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATA();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .OP2_FROM_OP1()
                .SIZE_LONG().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_MULS_MULU_DIVS_DIVU();

        p       .BRANCH_alu_signal().offset(<span class="stringliteral">&quot;div_no_div_by_zero_trap&quot;</span>);
        p               .TRAP_DIV_BY_ZERO()
                        .BRANCH_procedure().PROCEDURE_call_trap();
                        <span class="comment">// return after return</span>
        p               .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if no trap</span>
        p       .label(<span class="stringliteral">&quot;div_no_div_by_zero_trap&quot;</span>);

                <span class="comment">// push current micro pc on stack</span>
        p       .BRANCH_procedure().PROCEDURE_push_micropc();

                 <span class="comment">// check if operation finished</span>
        p       .BRANCH_alu_mult_div_ready().offset(<span class="stringliteral">&quot;mult_div_loop&quot;</span>);
        p               .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here after first loop finished</span>
        p       .label(<span class="stringliteral">&quot;mult_div_loop&quot;</span>);

        p       .ALU_MULS_MULU_DIVS_DIVU()
                .BRANCH_procedure().PROCEDURE_pop_micropc();

        p       .BRANCH_alu_signal().offset(<span class="stringliteral">&quot;mult_div_no_overflow&quot;</span>);
        p           .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if overflow</span>
        p       .label(<span class="stringliteral">&quot;mult_div_no_overflow&quot;</span>);
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_return();
        
        p.label(<span class="stringliteral">&quot;MICROPC_MOVEQ&quot;</span>);

        p       .OP1_MOVEQ()
                .SIZE_LONG().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .ALU_MOVE()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_BCHG_BCLR_BSET_immediate&quot;</span>);

        p       .SIZE_BYTE().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();
        
        p       .OP2_FROM_OP1()
                .SIZE_6().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        
        p       .ALU_BCHG_BCLR_BSET_BTST()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_BTST_immediate&quot;</span>);

        p       .SIZE_BYTE().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();
        
        p       .OP2_FROM_OP1()
                .SIZE_6().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATA();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_BCHG_BCLR_BSET_BTST()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_BCHG_BCLR_BSET_register&quot;</span>);

        p       .SIZE_6().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .OP2_FROM_OP1()
                .SIZE_6().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_BCHG_BCLR_BSET_BTST()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_BTST_register&quot;</span>);

        p       .SIZE_6().EA_REG_IR_11_9().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .OP2_FROM_OP1()
                .SIZE_6().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATA();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_BCHG_BCLR_BSET_BTST()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_TAS&quot;</span>);

        p       .READ_MODIFY_WRITE_FLAG_SET()
                .SIZE_BYTE().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_TAS()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .READ_MODIFY_WRITE_FLAG_CLEAR()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_NEGX_CLR_NEG_NOT_NBCD&quot;</span>);

        p       .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_NEGX_CLR_NEG_NOT_NBCD_SWAP_EXT()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_SWAP_EXT&quot;</span>);

        p       .SIZE_2().EA_REG_IR_2_0().EA_MOD_DN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_NEGX_CLR_NEG_NOT_NBCD_SWAP_EXT()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_TST&quot;</span>);

        p       .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_MOVE()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_ADDQ_SUBQ_not_An&quot;</span>);

        p       .OP2_ADDQ_SUBQ()
                .SIZE_3().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_read();

        p       .ALU_ARITHMETIC_LOGIC()
                .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_ADDQ_SUBQ_An&quot;</span>);

        p       .OP2_ADDQ_SUBQ()
                .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_ADDA_SUBA_CMPA_ADDQ_SUBQ()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_Scc&quot;</span>);

        p       .BRANCH_condition_0().offset(<span class="stringliteral">&quot;scc_condition_0&quot;</span>);
        p               .OP1_LOAD_ONES();

                <span class="comment">// jump here if condition is false</span>
        p       .label(<span class="stringliteral">&quot;scc_condition_0&quot;</span>);

        p       .BRANCH_condition_1().offset(<span class="stringliteral">&quot;scc_condition_1&quot;</span>);
        p               .OP1_LOAD_ZEROS();

                <span class="comment">// jump here if condition is true</span>
        p       .label(<span class="stringliteral">&quot;scc_condition_1&quot;</span>);

        p       .ALU_SIMPLE_MOVE()
                .SIZE_BYTE().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_Bcc_BRA&quot;</span>);

        p       .OP1_FROM_PC();

        p       .ALU_SIMPLE_MOVE()
                .BRANCH_ir().offset(<span class="stringliteral">&quot;bcc_bra_no_word&quot;</span>);

        p               .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                        .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();
        
        p               .OP1_FROM_IMMEDIATE()
                        .PC_INCR_BY_SIZE();

                <span class="comment">// jump here if no need to load extra immediate word</span>
        p       .label(<span class="stringliteral">&quot;bcc_bra_no_word&quot;</span>);

        p       .BRANCH_condition_0().offset(<span class="stringliteral">&quot;bcc_bra_no_branch&quot;</span>);

        p               .OP2_FROM_OP1();
        p               .OP2_MOVE_OFFSET()
                        .OP1_FROM_RESULT();

        p               .ALU_SIMPLE_LONG_ADD();

                        <span class="comment">// wait for instruction prefetch</span>
        p               .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();
        
        p               .PC_FROM_RESULT();

                        <span class="comment">// wait for PC check</span>
        p               .ALU_SIMPLE_MOVE();

                <span class="comment">// jump here if no branch</span>
        p       .label(<span class="stringliteral">&quot;bcc_bra_no_branch&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_DBcc&quot;</span>);

        p       .BRANCH_condition_1().offset(<span class="stringliteral">&quot;dbcc_condition_true&quot;</span>);

        p               .OP2_LOAD_1()
                        .SIZE_WORD().EA_REG_IR_2_0().EA_MOD_DN().EA_TYPE_ALL();

        p               .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p               .ALU_SIMPLE_LONG_SUB();

        p               .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p               .OP1_FROM_PC()
                        .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                        .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p               .BRANCH_result().offset(<span class="stringliteral">&quot;dbcc_condition_true&quot;</span>);

        p                       .OP1_FROM_IMMEDIATE()
                                .ALU_SIMPLE_MOVE();

        p                       .OP2_FROM_OP1()
                                .OP1_FROM_RESULT();

        p                       .ALU_SIMPLE_LONG_ADD()
                                <span class="comment">// wait for instruction prefetch</span>
                                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p                       .PC_FROM_RESULT();

                                <span class="comment">// wait for PC check</span>
        p                       .ALU_SIMPLE_MOVE();
        
        p                       .BRANCH_procedure().PROCEDURE_return();

                <span class="comment">// jump here if condition is true</span>
        p       .label(<span class="stringliteral">&quot;dbcc_condition_true&quot;</span>);

        p       .PC_INCR_BY_2()
                .BRANCH_procedure().PROCEDURE_return();
        
        p.label(<span class="stringliteral">&quot;MICROPC_MOVE_FROM_SR&quot;</span>);

        p       .OP1_FROM_SR()
                .SIZE_WORD().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATAALTER();

        p       .ALU_SIMPLE_MOVE()
                .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVE_TO_CCR_MOVE_TO_SR&quot;</span>);

        p       .SIZE_WORD().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_DATA();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_MOVE_TO_CCR_SR_RTE_RTR_STOP_LOGIC_TO_CCR_SR()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_MOVE_USP_to_USP&quot;</span>);

        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

        p       .ALU_SIMPLE_MOVE();

        p       .AN_ADDRESS_USP()
                .AN_WRITE_ENABLE_SET();

        p       .BRANCH_procedure().PROCEDURE_return();
                
                
        p.label(<span class="stringliteral">&quot;MICROPC_MOVE_USP_to_An&quot;</span>);

        p       .OP1_FROM_USP()
                .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();

        p       .ALU_SIMPLE_MOVE()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_LINK&quot;</span>);

                <span class="comment">// load An to OP1</span>
        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

                <span class="comment">// move OP1 to result</span>
        p       .ALU_LINK_MOVE()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();

                <span class="comment">// write result to (SP)</span>
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

                <span class="comment">// load SP to OP1</span>
        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_AN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

                <span class="comment">// move OP1 to result</span>
        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();

                <span class="comment">// save result to An</span>
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

                <span class="comment">// load offset word to OP1</span>
        p       .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();

                <span class="comment">// move OP1 to OP2</span>
        p       .OP2_FROM_OP1()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_AN().EA_TYPE_ALL();

                <span class="comment">// load SP to OP1</span>
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

                <span class="comment">// add offset and SP to SP</span>
        p       .ALU_SIMPLE_LONG_ADD()
                .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_ULNK&quot;</span>);
                <span class="comment">// load An to OP1</span>
        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();

                <span class="comment">// move OP1 to result</span>
        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_AN().EA_TYPE_ALL();

                <span class="comment">// save result to SP</span>
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

                <span class="comment">// load (SP) to OP1</span>
        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_POSTINC().EA_TYPE_ALL();
        p       .BRANCH_procedure().PROCEDURE_call_load_ea();
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();
        
                <span class="comment">// move OP1 to result</span>
        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_AN().EA_TYPE_ALL();

                <span class="comment">// save result to An</span>
        p       .BRANCH_procedure().PROCEDURE_call_perform_ea_write();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_BSR&quot;</span>);

        p       .OP1_FROM_PC();

        p       .ALU_SIMPLE_MOVE()
                .BRANCH_ir().offset(<span class="stringliteral">&quot;bsr_no_word&quot;</span>);
        p               .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                        .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p               .OP1_FROM_IMMEDIATE()
                        .PC_INCR_BY_SIZE();

                <span class="comment">// jump here if no need to load extra immediate word</span>
        p       .label(<span class="stringliteral">&quot;bsr_no_word&quot;</span>);

        p       .OP2_FROM_OP1();
        p       .OP2_MOVE_OFFSET()
                .OP1_FROM_RESULT();

        p       .ALU_SIMPLE_LONG_ADD();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .OP1_FROM_PC()
                .PC_FROM_RESULT();

        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();

        p       .ALU_SIMPLE_MOVE()
                .BRANCH_procedure().PROCEDURE_call_load_ea();
                
        p       .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_JMP&quot;</span>);

        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .OP1_FROM_ADDRESS();
        p       .ALU_SIMPLE_MOVE();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .PC_FROM_RESULT();

                <span class="comment">// wait for PC check</span>
        p       .ALU_SIMPLE_MOVE();
        
        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_JSR&quot;</span>);

        p       .SIZE_LONG().EA_REG_IR_2_0().EA_MOD_IR_5_3().EA_TYPE_CONTROL();

        p       .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .OP1_FROM_ADDRESS();
        p       .ALU_SIMPLE_MOVE();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .OP1_FROM_PC()
                .PC_FROM_RESULT();

        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_PREDEC().EA_TYPE_ALL();

        p       .ALU_SIMPLE_MOVE()
                .BRANCH_procedure().PROCEDURE_call_load_ea();

        p       .BRANCH_procedure().PROCEDURE_call_write();

        p.label(<span class="stringliteral">&quot;MICROPC_RTE_RTR&quot;</span>);

        p       .SIZE_WORD().EA_REG_3b111().EA_MOD_POSTINC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_SIMPLE_MOVE()
                .SIZE_LONG().EA_REG_3b111().EA_MOD_POSTINC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_SIMPLE_MOVE()
                .OP1_FROM_RESULT();
        p       .ALU_MOVE_TO_CCR_SR_RTE_RTR_STOP_LOGIC_TO_CCR_SR();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .PC_FROM_RESULT();
        
                <span class="comment">// wait for PC check</span>
        p       .ALU_SIMPLE_MOVE();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_RTS&quot;</span>);

        p       .SIZE_LONG().EA_REG_3b111().EA_MOD_POSTINC().EA_TYPE_ALL();

        p       .BRANCH_procedure().PROCEDURE_call_read();
        p       .BRANCH_procedure().PROCEDURE_call_save_ea();

        p       .ALU_SIMPLE_MOVE();

                <span class="comment">// wait for instruction prefetch</span>
        p       .BRANCH_procedure().PROCEDURE_wait_prefetch_valid();

        p       .PC_FROM_RESULT();

                <span class="comment">// wait for PC check</span>
        p       .ALU_SIMPLE_MOVE();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_NOP&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_TRAP&quot;</span>);

        p       .TRAP_TRAP()
                .BRANCH_procedure().PROCEDURE_call_trap();

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_TRAPV&quot;</span>);

        p       .BRANCH_V().offset(<span class="stringliteral">&quot;trapv_no_trap&quot;</span>);

        p               .TRAP_TRAPV()
                        .BRANCH_procedure().PROCEDURE_call_trap();

                <span class="comment">// jump here if overflow == 0</span>
        p       .label(<span class="stringliteral">&quot;trapv_no_trap&quot;</span>);

        p       .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_RESET&quot;</span>);

        p       .DO_RESET_FLAG_SET();
        p       .BRANCH_procedure().PROCEDURE_wait_finished();
        
        p       .DO_RESET_FLAG_CLEAR()
                .BRANCH_procedure().PROCEDURE_return();

        p.label(<span class="stringliteral">&quot;MICROPC_STOP&quot;</span>);

        p       .SIZE_WORD().EA_REG_3b100().EA_MOD_3b111().EA_TYPE_ALL()
                .BRANCH_procedure().PROCEDURE_wait_prefetch_valid_32();

        p       .OP1_FROM_IMMEDIATE()
                .PC_INCR_BY_SIZE();

        p       .ALU_MOVE_TO_CCR_SR_RTE_RTR_STOP_LOGIC_TO_CCR_SR()
                .STOP_FLAG_SET()
                .BRANCH_procedure().PROCEDURE_return();
    }
}
</pre></div> </div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Jan 16 2011 11:00:03 for ao68000 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
