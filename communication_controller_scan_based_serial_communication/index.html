<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='scan_based_serial_communication.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: scan_based_serial_communication
    <br/>
    Created: Jul 19, 2010
    <br/>
    Updated: Jul 22, 2010
    <br/>
    SVN Updated: Apr  9, 2013
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Communication controller
    
    <br/>
    Language:
    
     Verilog
    
    <br/>
    Development status:
    
     Stable
    
    <br/>
    Additional info:
    <br/>
    WishBone Compliant: No
    <br/>
    License: BSD
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     <div style="right; margin: 10px 10px 10px 10px;">
      <img src="usercontent,img,1279812126" alt="Block Diagram" width="500/"/>
     </div>
     This is a scan based serial communication block designed to safely and easily move data onto and off of a chip with a minimal number of pins. Performance is not a priority, however, we have found it to be sufficiently fast most any student project. It has been used, successfully, on many tapeouts.
     <br/>
     Included is an on-chip synthesizble scan block and an off-chip testbench to interact with it.
     <br/>
     <img src="usercontent,img,1279812062" alt="Overview Flowchart" width="350"/>
     <br/>
     The on-chip scan block has six pad signals that go off-chip, and a configurable number of on-chip data input and output signals. Data signals from on-chip, going off-chip, can be latched into the scan chain and scanned out. Data signals going from off-chip to on-chip can be scanned into the chip, then stored into a latch that drives the output of the module. The buffering latch prevents data that is coming on-chip to not toggle randomly while the scan chain is active.
     <br/>
     Due to the buffering latches, complex internal interfaces can be emulated using the scan chain. For instance, an SRAM could be connected to a clock, chip select, write enable, 64-bit data-in,  and 64-bit data-out, all of which are connected to the scan chain. The scan chain would need to be used a few times for each "cycle" of the SRAM. For instance, each time the clock signal toggles the scan chain would need to be completely reloaded. Although this process is slow, it works reliably.
     <br/>
     The scan chain is implemented with a simple Perl-based script called
     
      deperlify
     
     to make the scan chain easily reconfigurable (a copy is included). A single configuration file generates a synthesizble scan block (for on-chip) and a testbench to test it, which allows rapid changes with minimal errors. The testbench has a number of tasks to easily access the on-chip structures.
     <br/>
     This code was originally developed by
     
      David Fick
     
     at the University of Michigan
     
      VLSI Design/Automation Lab
     
     .
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 12 June 2015</p>
